#+STARTUP: overview
#+STARTUP: indent
* require
#+begin_src emacs-lisp :tangle yes
  (require 'cc-mode)
  (require 'seq)
  (require 'multiple-cursors)
  (require 'evil)
  (require 'evil-numbers)

#+end_src
* faces
#+begin_src emacs-lisp :tangle yes
  (defface eriks-fix-later-face
    '((t :foreground "orange1"
         :background "gray10"
         :weight bold
         ))
    "Face to highlight FIXME and TODO")

  (defun add-todo-font-lock ()
    (interactive)
    (font-lock-add-keywords nil
                            '(("\\<\\(FIXME\\):" 1 'eriks-fix-later-face t)
                              ("\\<\\(TODO\\):" 1 'eriks-fix-later-face t))))


#+end_src
* Eriks keys minor mode
[[https://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs/5340797][Source from stackoverflow]]
#+begin_src emacs-lisp :tangle yes
  ;;(defvar my-keys-minor-mode-map
  ;;  (let ((map (make-sparse-keymap)))

  ;;    map)
  ;;  "my-keys-minor-mode keymap.")

  (setq my-keys-map (make-sparse-keymap)) ;;varför gör jag såhär?

  (define-minor-mode my-keys-minor-mode
    "my keymode to activate my keybindings"
    :global t
    :init-value t
    :lighter " my-keys"
    :keymap my-keys-map)

  ;; (define-globalized-minor-mode my-keys-global-mode
  ;;   my-keys-minor-mode
  ;;   (lambda ()
  ;;     (my-keys-minor-mode 1)))

  (my-keys-minor-mode 1)
  ;;(my-keys-global-mode 1)

  (global-set-key (kbd "<f1>") 'my-keys-minor-mode)

  ;;-----turn off i minibuffer------
  ;;(defun my-minibuffer-setup-hook ()
  ;;  (my-keys-minor-mode 0))

  ;;(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

  ;;-----reloada om en minor mode kommer in-----
  (add-hook 'after-load-functions 'my-keys-have-priority)

  (defun my-keys-have-priority (_file)
    "Try to ensure that my keybindings retain priority over other minor modes. Called via the `after-load-functions' special hook."
    (unless (eq (caar minor-mode-map-alist) 'my-keys-minor-mode)
      (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
        (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
        (add-to-list 'minor-mode-map-alist mykeys))))
#+end_src
** locally override
If you want to "always use the keybinds in the map, unless I explicitly
override them for a specific mode-map", and assuming you are using
scottfrazier's approach, you want:

So
#+begin_src emacs-lisp :tangle yes
(defun locally-override (key cmd)
    (unless (local-variable-p 'my-keys-minor-mode-map)
      (set (make-variable-buffer-local 'my-keys-minor-mode-map)
           (make-sparse-keymap))
      (set-keymap-parent my-keys-minor-mode-map
                         (default-value 'my-keys-minor-mode-map)))
    (define-key my-keys-minor-mode-map key cmd))
#+end_src
(locally-override "\C-i" nil)

should remove the "\C-i" binding from the minor mode in the current buffer only.
Warning: this is completely untested, but seems like the right approach.
The point of setting the parent rather than just coping the global value of
my-keys-minor-mode-map is so any later changes to the global value are automatically
reflected in the local value.
* misc
#+begin_src emacs-lisp :tangle yes
  (browse-kill-ring-default-keybindings)
  ;; (powerline-default-theme)

  ;;(require 'all-the-icons)
  ;; (require 'all-the-icons-ivy)
  ;; (all-the-icons-ivy-setup)
  ;;(all-the-icons-dired-mode)

  (require 'smart-mode-line)
  (sml/setup)

  (fset 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  (which-key-mode 1)
  ;;(setq org-ellipsis "⬎")
  ;;(smart-mode-line-enable)
  (setq inhibit-startup-screen t)
  ;; (setq auto-save-file-name-transforms
  ;;       (let (dir (expand-file-name "~/.emacs_auto_saves"))
  ;;         `((".*" dir t))))
                                          ; auto save path
  (defvar autosave-dir (concat "~/.emacs_auto_saves" "/"))
  (make-directory autosave-dir t)
  (setq auto-save-file-name-transforms
        `(("\\(?:[^/]*/\\)*\\(.*\\)" ,(concat autosave-dir "\\1") t)))

  ;;(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)

  (winner-mode 1)

  ;; (global-disable-mouse-mode)

  (define-key my-keys-map (kbd "C-+") 'er/expand-region)
  (define-key my-keys-map (kbd "M-s q") 'isearch-query-replace-regexp)
  (define-key my-keys-map (kbd "M-s r") 'isearch-forward-regexp)
  (define-key my-keys-map (kbd "M-s R") 'isearch-backward-regexp)
  (define-key my-keys-map (kbd "M-s s") 'isearch-forward)
  (define-key my-keys-map (kbd "M-s S") 'isearch-backward)

  (define-key my-keys-map (kbd "H-t") 'transpose-chars)

  ;; remove some annoying keybindings
  (global-set-key (kbd "<home>") nil)
  (global-set-key (kbd "<end>") nil)
  (global-set-key (kbd "<prior>") nil)
  (global-set-key (kbd "<next>") nil)

  ;;magit fixar detta redan med ett egen global mode
  ;;(global-auto-revert-mode t)

  ;;(define-key input-decode-map [?\C-i] [C-i])
  ;;(global-set-key (kbd "<C-i>") 'indent-region)
  ;;(define-key input-decode-map [?\C-m] [C-m])
  ;;(global-set-key (kbd "<C-i>") 'indent-region)

  (defun replace-char (c)
    "Replaces current char with a prompted one"
    (interactive "cReplacement: ")
    (delete-char 1)
    (insert-char c)
    (backward-char)
    )

  (define-key my-keys-map (kbd "C-r") 'replace-char)

  ;;support för font awesome
  ;; (set-fontset-font "fontset-default" '(#xf000 . #xffff) "Font Awesome")

  (defun backward-symbol (&optional arg)
   "Move backward until encountering the beginning of a symbol.
  With argument, do this that many times."
   (interactive "p")
   (forward-symbol (- (or arg 1))))

  (define-key my-keys-map (kbd "<f3>") 'kmacro-start-macro)

  (defun eriks-pop-kill-ring ()
    (interactive)
    (setq kill-ring (cdr kill-ring))
    (setq kill-ring-yank-pointer kill-ring))

  (setq line-move-visual nil)

  ;;to fix bug with expand-region (issue 220 on github)
  (setq shift-select-mode nil)

  (define-key my-keys-map (kbd "M-a") 'back-to-indentation)

  ;; auto indent with yank
  ;; from emacswiki
  (dolist (command '(yank yank-pop))
    (eval `(defadvice ,command (after indent-region activate)
             (and (not current-prefix-arg)
                  (member major-mode '(emacs-lisp-mode lisp-mode
                                                       clojure-mode    scheme-mode
                                                       haskell-mode    ruby-mode
                                                       rspec-mode      python-mode
                                                       c-mode          c++-mode
                                                       objc-mode       latex-mode
                                                       plain-tex-mode))
                  (let ((mark-even-if-inactive transient-mark-mode))
                    (indent-region (region-beginning) (region-end) nil))))))

  (defun eval-last-sexp-replace ()
    "Runs `eval-last-sexp' and replaces the sexp with the evaluated value"
    (interactive)
    (let ((start (point)))
      (setq current-prefix-arg '(4))
      (call-interactively 'eval-last-sexp)
      (save-excursion
        (goto-char start)
        (let ((sexp-end (point)))
          (backward-sexp)
          (delete-region (point) sexp-end)))))

  (define-key my-keys-map (kbd "C-x M-e") 'eval-last-sexp-replace)

  ;;(add-hook 'after-save-hook 'whitespace-cleanup)
  ;;(define-key my-keys-map (kbd "M-SPC") 'cycle-spacing)
  (define-key my-keys-map (kbd "<f8>") 'speedbar)

  (setq browse-url-browser-function 'browse-url-generic browse-url-generic-program "xdg-open")

  (defun eriks-up-indentation ()
    (interactive)
    (back-to-indentation)
    (let ((start (current-column)))
      (while (and
              (> (current-column) 0)
              (>= (current-column) start))
        (forward-line -1)
        (back-to-indentation))))

  (defun eriks-up-same-column (&optional dir)
    (interactive)
    (let ((start (current-column))
          (prev (point))
          (dir (if (null dir) -1 dir)))
      (while (and
              (= (move-to-column start) start))
        (setq prev (point))
        (forward-line dir))
      (goto-char prev)))

  (defun eriks-down-same-column ()
    (interactive)
    (eriks-up-same-column 1))
#+end_src
* Eriks map / prefix key
** random
#+begin_src emacs-lisp :tangle yes
  (define-prefix-command 'eriks-map)
  ;;(global-set-key (kbd "C-ö") 'eriks-map)
  (define-key my-keys-map (kbd "S-SPC") 'eriks-map)
  ;;(define-key my-keys-map (kbd "<C-m>") 'set-mark-command)

  (define-key eriks-map (kbd "e") 'eclim-project-mode)

  (define-key eriks-map (kbd "f r") 'fill-region)
  (define-key eriks-map (kbd "f p") 'fill-region-as-paragraph)
  (define-key eriks-map (kbd "f f") 'fill-paragraph)

  (define-key eriks-map (kbd "C-f") 'ff-find-other-file)

  (define-key eriks-map (kbd "r") 'linum-relative-toggle)
  (linum-relative-toggle)

  (define-key eriks-map (kbd "l") 'eriks-toggle-visual-line)

  (defun eriks-toggle-visual-line ()
    (interactive)
    (setq line-move-visual (not line-move-visual)))

  ;; (defun eriks-kill-line ()
  ;;   "Kills (cuts) the whole current line"
  ;;   (interactive)
  ;;   (setq col (current-column))
  ;;   (beginning-of-line)
  ;;   (delete-horizontal-space)
  ;;   (set-mark-command nil)
  ;;   (end-of-line)
  ;;   (if (not (eq (point) (mark)))
  ;;       (kill-region (point) (mark)))
  ;;   (deactivate-mark)
  ;;   ;;(kill-line 1)
  ;;   (delete-forward-char 1)
  ;;   (move-to-column col))

  ;; (define-key eriks-map (kbd "d") 'eriks-kill-line)

  (defun eriks-add-semicolon ()
    "Goes to the end of the current line and adds an semicolon."
    (interactive)
    (move-end-of-line nil)
    (insert ";"))

  (defun eriks-add-semicolon-and-newline ()
    "what the name says"
    (interactive)
    (eriks-add-semicolon)
    (newline-without-break-down))


  (define-key eriks-map (kbd ":") 'eriks-add-semicolon)
  (define-key eriks-map (kbd ";") 'eriks-add-semicolon-and-newline)

  (defun eriks-insert-paren (p)
    (interactive "p")
    (end-of-line)
    (insert p)
    (left-char)
    (newline)
    (newline)
    (indent-for-tab-command)
    (forward-line -1)
    (indent-for-tab-command)
    )

  ;; (define-key eriks-map (kbd "{") ;;TODO flytta till c-map
  ;;   (lambda ()
  ;;     (interactive)
  ;;     (eriks-insert-paren "{}")))

  (define-key eriks-map (kbd "y") 'ansi-term)

  ;;(define-key eriks-map (kbd "C-c") 'whitespace-cleanup)

  ;; (defun edit-myinit-org ()
  ;;   (interactive)
  ;;   (find-file (expand-file-name "~/.emacs.d/myinit.org")))

  ;;(define-key eriks-map (kbd "i") 'edit-myinit-org)

  (define-key eriks-map (kbd "gs") 'magit-status)
  (define-key eriks-map (kbd "U") 'counsel-unicode-char)
  ;;(define-key eriks-map (kbd "M") 'counsel-mark-ring)

  (defun sign (a)
    "The sign of a typ
  a >= 0 ->  1
  a <  0 -> -1"
    (if (>= a 0)
        1
      -1))

  (defun abs (a)
    "abs av a"
    (if (< a 0)
        (- 0 a)
      a))

  (define-key eriks-map (kbd "n +") 'evil-numbers/inc-at-pt)
  (define-key eriks-map (kbd "n -") 'evil-numbers/dec-at-pt)

  (define-key eriks-map (kbd "a a") 'align)
  (define-key eriks-map (kbd "a r") 'align-regexp)
  (define-key eriks-map (kbd "a c") 'align-current)

  (defun eriks-buffer-text-to-raw ()
    (interactive)
    (let ((inhibit-read-only t))
      (set-text-properties (point-min) (point-max) nil)))

  (define-key eriks-map (kbd "C-r") 'eriks-buffer-text-to-raw)

  (define-key eriks-map (kbd "d") 'delete-duplicate-lines)

  ;; Set transparency of emacs
  (defun transparency (value)
    "Sets the transparency of the frame window. 0=transparent/100=opaque"
    (interactive "nTransparency Value 0 - 100 opaque:")
    (set-frame-parameter (selected-frame) 'alpha value))

  (define-key eriks-map (kbd "C-t") 'transparency)
#+end_src
** lxor & is-whitespace
#+begin_src emacs-lisp :tangle yes
  (defun lxor (a b)
    "logical xor"
    (and
     (not (and a b))
     (or a b)))

  (defun lxnor (a b)
    "logical xnor"
    (not (lxor a b)))

  (defun is-whitespace (char &optional NOTNEWLINE)
    "Checks whether char is a space, newline or tab.
  if NOTNEWLINE, then don't count newlines as whitespace."
    (or
     (= char 32) ;;space
     (and (not NOTNEWLINE) (= char 10)) ;;newline
     (= char 9)  ;; tab
     ;;(bolp)
     ;;(eolp)
     ))
#+end_src
** erik-funktioner
#+begin_src emacs-lisp :tangle yes
  ;; (defun eriks-kill-stuff (dir symbol arg)
  ;;   (if (equal arg '(4))
  ;;       (eriks-hungry-delete-whitespace dir)
  ;;     (let ((p (* dir (prefix-numeric-value arg))))
  ;;       (if symbol
  ;;           (sp-kill-symbol p)
  ;;         (sp-kill-word p)))))

  ;; (defun eriks-kill-backward (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff -1 nil ARG))

  ;; (defun eriks-kill-forward (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff 1 nil ARG))

  ;; (defun eriks-kill-forward-symbol (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff 1 t ARG))

  ;; (defun eriks-kill-backward-symbol (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff -1 t ARG))

  (defun eriks-hungry-delete-whitespace (ARG)
    (interactive "p")
    (if (< ARG 0)
        (while (is-whitespace (preceding-char))
          (delete-backward-char 1))
      (while (is-whitespace (following-char))
        (delete-char 1))))

  (defun eriks-hungry-delete-whitespace-backward (ARG)
    (interactive "p")
    (eriks-hungry-delete-whitespace (- 0 ARG)))

  ;; (define-key my-keys-map (kbd "C-<backspace>") 'eriks-delete-backward)
  ;; (define-key my-keys-map (kbd "C-<delete>") 'eriks-delete-forward)

  (defun eriks-duplicate-line ()
    (interactive)
    (let* ((b (progn
                (beginning-of-line)
                (point)))
           (e (progn
                (end-of-line)
                (point)))
           (line (buffer-substring b e)))
      (end-of-line)
      (newline)
      (insert line)))

  ;;TODO make ARG execute the command ARG times
  (defun eriks-find-char (ARG c)
    "Like vim's f-command.

  With no prefix argument or as 1, move cursor forward until the first occurence of c.
  With ARG as -1 (M--), move backward until the first occurence of c.
  If c can't be found, do nothing and print a nice message.

  Ignores case!

  returns t if successful, nil otherwise"
    (interactive "p\ncJump to char: ")
    (let ((dir (sign ARG))
          (start (point))
          (finished nil))
      (while (and
              (not (or
                    (and (> dir 0) (eobp))
                    (and (< dir 0) (bobp))))
              (not finished))
        (forward-char dir)
        (if (= (downcase c) (downcase (following-char)))
            (setq finished t)))
      (if (not finished)
          (progn
            (goto-char start)
            (message "Couldn't find '%c' :(" c)
            nil)
        t)))

  (defun eriks-find-char-backward (ARG c)
    "Exactly the same behaviour as `eriks-find-char' except this goes backwards by negating ARG"
    (interactive "p\ncJump to char backwards: ")
    (eriks-find-char (- 0 ARG) c))

  (defun eriks-find-char-alt ()
    (interactive)
    (if (call-interactively 'eriks-find-char)
        (forward-char)))

  (defun eriks-find-char-alt-backward ()
    (interactive)
    (if (call-interactively 'eriks-find-char-backward)
        (forward-char)))

  (defun eriks-skip-space (ARG &optional SAMELINE)
    "Move point forward or backward until it doesnt encounter whitespace anymore.
  if SAMELINE then don't move the cursor between lines."
    (interactive "p")
    (if (< ARG 0)
        (while (is-whitespace (preceding-char) SAMELINE)
          (left-char))
      (while (is-whitespace (following-char) SAMELINE)
        (right-char))))

  (defun eriks-skip-space-backwards (&optional SAMELINE)
    (interactive)
    (eriks-skip-space -1 SAMELINE))

  (defun eriks-kill-paragraph ()
    "Kills the current paragraph point is in."
    (interactive)
    (eriks-kill-thing-at-point 'paragraph))

  (defun eriks-backward-kill-line ()
    (interactive)
    (kill-line 0))

  (defun eriks-mark-line ()
    (interactive)
    (beginning-of-line)
    (push-mark (point) nil t)
    (end-of-line))

  (defun eriks-insert-char (ARG c)
    (interactive "p\ncInsert: ")
    (dotimes (i ARG)
      (insert c)))
#+end_src
** o and O from VIM
#+begin_src emacs-lisp :tangle yes
  (setq newline-without-break-tab nil)

  (defun newline-without-break-down ()
    "Add new line below and go to it. tab if an argument is given"
    (interactive)
    (end-of-line)
    (newline)
    (if newline-without-break-tab (indent-according-to-mode)))

  (defun newline-without-break-up ()
    "Add new line above and go to it. tab if an argument is given"
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (if newline-without-break-tab (indent-according-to-mode)))

  ;;(define-key cua-global-keymap [C-return] nil) ;;ta bort C-return from cua
  (define-key my-keys-map (kbd "<C-return>") 'newline-without-break-down)
  (define-key my-keys-map (kbd "<C-S-return>") 'newline-without-break-up)

#+end_src
** move lines from internet

#+begin_src emacs-lisp :tangle yes
  ;; (defun move-line (n)
  ;;   "Move the current line up or down by N lines. Buggar for second last line i buffern"
  ;;   (interactive "p")
  ;;   (setq col (current-column))
  ;;   (beginning-of-line)
  ;;   (setq start (point))
  ;;   (end-of-line)
  ;;   (if (eobp)
  ;;       (newline)
  ;;     (forward-char))
  ;;   (setq end (point))
  ;;   (let ((line-text (delete-and-extract-region start end)))
  ;;     (forward-line n)
  ;;     (if (eobp) (newline))
  ;;     (insert line-text)
  ;;     ;; restore point to original column in moved line
  ;;     (forward-line -1)
  ;;     (move-to-column col)))

  ;; (defun move-line-up (n)
  ;;   "Move the current line up by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) -1 (- n))))

  ;; (defun move-line-down (n)
  ;;   "Move the current line down by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) 1 n)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (transpose-lines 1)
      (previous-line 2)
      (move-to-column col)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (next-line 1)
      (transpose-lines 1)
      (previous-line 1)
      (move-to-column col)))

  ;; (define-key my-keys-map (kbd "M-<up>") 'move-line-up)
  ;; (define-key my-keys-map (kbd "M-<down>") 'move-line-down)

#+end_src
** vims w
#+begin_src emacs-lisp :tangle yes
  (defun char-is (classs dir)
    "t if current char is in any character class in the list classs.
  If dir < 0, do the same check on previous character instead"
    (let ((found nil))
      (dolist (cla classs)
        (setq found (or
                     found
                     (= (char-syntax
                         (if (>= dir 0)
                             (following-char)
                           (preceding-char)))
                        cla))))
      found))

  (defun eriks-next-class (classs dir)
    "Moves point in 'dir' until it encounters something in the character class the list 'classs'"
    (let ((running t)
          (old_onclass (char-is classs dir))
          (onclass nil))
      (while running
        (setq onclass (char-is classs dir))
        (if (and
             (null old_onclass)
             onclass)
            (setq running nil)
          (progn
            (forward-char dir)
            (setq old_onclass onclass))))))

  (defun eriks-next-word (dir)
    "Moves point to the beginning of next word
  or end of previous word if dir < 0"
    (interactive "p")
    (dotimes (i (abs dir))
      (eriks-next-class '(?w) (sign dir))))

  (defun eriks-prev-word (dir)
    "`eriks-next-word' but dir always negated."
    (interactive "p")
    (eriks-next-word (- 0 dir)))

  (defun eriks-next-symbol (dir)
    "Moves point to the beginning of next symbol
  or end of previous symbol if dir < 0"
    (interactive "p")
    (dotimes (i (abs dir))
      (eriks-next-class '(?_ ?w) (sign dir))))
#+end_src
** slurp
#+begin_src emacs-lisp :tangle yes
  (defun eriks-slurp (b e)
    "Flyttar parantesen i aktiva region till slutet av region och indentar all"
    (interactive "r")
    (let* ((paren (delete-and-extract-region b (+ b 1))))
      (goto-char (- e 1))
      (insert "\n")
      (insert paren)
      (indent-region b (+ e 1))))

  (define-key eriks-map (kbd "s") 'eriks-slurp)

  (defvar last-post-command-position 0
    "Holds the cursor position from the last run of post-command-hooks.")

  (make-variable-buffer-local 'last-post-command-position)

  (defvar eriks-sticky-char nil)

  (defun eriks-sticky-toggle ()
    "Makes char under cursor to be 'sticky'.
  The characters follows the cursor as long as this function is active.

  ---Works most of the time---"
    (interactive)
    (setq eriks-sticky-char (not eriks-sticky-char))
    (setq last-post-command-position (point)))

  (define-key eriks-map (kbd "C-s") 'eriks-sticky-toggle)

  (defun do-stuff-if-moved-post-command ()
    (if eriks-sticky-char
        (progn
          (message "Sticky on...")
          (unless (equal (point) last-post-command-position)
            (let* ((new (point))
                   (delta (- new last-post-command-position)))
              (goto-char last-post-command-position)
              (let ((c (following-char)))
                (delete-char 1)
                (forward-char delta)
                (save-excursion
                  (insert c)))))
          (setq last-post-command-position (point)))
        ;; (progn
        ;;   (let ((new (point)))
        ;;     (unless (equal new last-post-command-position)
        ;;       (let ((m (delete-and-extract-region last-post-command-position (+ 1 last-post-command-position))))
        ;;         (goto-char new)
        ;;         (save-excursion
        ;;           (insert m)))))
        ;;   (setq last-post-command-position (point)))
      ))

  (add-hook 'post-command-hook 'do-stuff-if-moved-post-command)


#+end_src
** c extract header
#+begin_src emacs-lisp :tangle yes
  (setq extract-c-regexp "^\\([[:graph:]]+[[:blank:]]+[^[:space:]]+(.*)\\)\\s-*{?\\s-*$")

  (defun extract-c-copy-next-declaration (&optional append)
    "Copies the next function declaration in a c-file as a standalone declaration.
  If append, then append the copied value to the last one
  Returns t if successfully found one, nil otherwise"
    (interactive)
    (if (re-search-forward extract-c-regexp nil t)
        (let* ((decl (buffer-substring (match-beginning 1) (match-end 1)))
               (semi (concat decl ";\n")))
          (if append
              (kill-append semi nil)
            (kill-new semi))
          t)
      nil))

  (defun extract-c-copy-all-declarations ()
    "Copies all function declarations in a buffer to the kill-ring."
    (interactive)
    (save-excursion
      (beginning-of-buffer)
      (let ((first t))
        (while (extract-c-copy-next-declaration (not first))
          (setq first nil)))))

  (define-key eriks-map (kbd "c a") 'extract-c-copy-all-declarations)
  (define-key eriks-map (kbd "c n") 'extract-c-copy-next-declaration)
#+end_src
** exchange two regions
#+begin_src emacs-lisp :tangle yes
  (setq eriks-regions-saved nil)

  (defun eriks-region-switch-abort ()
    "Abort current transpose"
    (interactive)
    (setq eriks-regions-saved nil)
    (message "aborted..."))

  (defun eriks-region-switch (a b)
    "Switches two regions.
  Activate an region and then:
     1st call: save the region for switching (abort with `eriks-region-switch-abort')
     2nd call: switch!"
    (interactive "r")
    (if (not mark-active)
        (message "Mark not active...")
      (progn
        (deactivate-mark)
        (if (null eriks-regions-saved)
            (setq eriks-regions-saved (simplify-region (cons a b)))
          (let* ((sim (simplify-region (cons a b)))
                 (old eriks-regions-saved)
                 (sorted (sort-regions sim old))
                 (left (car sorted))
                 (right (cdr sorted))
                 (leftl (region-size left))
                 (rightl (region-size right)))
            (if (region-overlap left right)
                (message "De overlappar")
              (progn
                (let* ((a (delete-and-extract-region (car left) (cdr left)))
                       (nright (translate-region right (- 0 leftl)))
                       (b (delete-and-extract-region (car nright) (cdr nright))))
                  (goto-char (car nright))
                  (insert a)
                  (goto-char (car left))
                  (insert b))))
            (setq eriks-regions-saved nil))))))

  (defun region-size (r)
    (- (cdr r) (car r)))

  (defun simplify-region (r)
    (let ((a (car r))
          (b (cdr r))))
    (cons (min a b) (max a b)))

  (defun sort-regions (r a)
    (if (< (car r) (car a))
        (cons r a)
      (cons a r)))

  (defun region-overlap (r a)
    (not (or
          (<= (cdr r) (car a))
          (>= (car r) (cdr a)))))

  (defun translate-region (r x)
    (cons (+ (car r) x) (+ (cdr r) x)))

  (defun sort-region (r)
    "in ascending order. min first."
    (cons
     (min (car r) (cdr r))
     (max (car r) (cdr r))))

  (defun swap-cons (c)
    (cons (cdr c) (car c)))

#+end_src

** copy char
#+begin_src emacs-lisp :tangle yes
  (defun eriks-kill-dwim (f BEG END &optional region)
    "If a region is active, then do f as normal.
  But if it is inactive, then f the current char at point."
    (if (region-active-p)
        (funcall f BEG END)
      (progn
        (push-mark (+ (point) 1) t t)
        (funcall f (point) (mark)))))

  (advice-add 'kill-ring-save :around 'eriks-kill-dwim)
  (advice-add 'kill-region :around 'eriks-kill-dwim)
  (advice-add 'sp-kill-region :around 'eriks-kill-dwim)

  ;; (defun eriks-kill-dwim ()
  ;;   (interactive)
  ;;   (if (region-active-p)
  ;;       (kill-region (region-beginning) (region-end))
  ;;     (kill-new (string (following-char)))))
#+end_src
** tabs
#+begin_src emacs-lisp :tangle yes
  (defun configure-tabs (width tabs)
    (interactive "nTab width: \nnAllow tabs? (0/1/-1): ")
    (setq tab-width      width
          c-basic-offset width)
    (cond
     ((> tabs 0)
      (setq indent-tabs-mode t))
     ((< tabs 0)
      (setq indent-tabs-mode nil))))

  (define-key eriks-map (kbd "T t") 'configure-tabs)
  (define-key eriks-map (kbd "T U") 'untabify)
  (define-key eriks-map (kbd "T u") 'tabify)
  (define-key eriks-map (kbd "T w") 'whitespace-cleanup)
  (define-key eriks-map (kbd "T e") 'delete-trailing-whitespace)
#+end_src
* packages
** windmove and framemove
#+begin_src emacs-lisp :tangle yes
  (require 'framemove)

  (define-key my-keys-map (kbd "S-<right>") 'windmove-right)
  (define-key my-keys-map (kbd "S-<left>") 'windmove-left)
  (define-key my-keys-map (kbd "S-<up>") 'windmove-up)
  (define-key my-keys-map (kbd "S-<down>") 'windmove-down)

  (define-key my-keys-map (kbd "H-l") 'windmove-right)
  (define-key my-keys-map (kbd "H-h") 'windmove-left)
  (define-key my-keys-map (kbd "H-k") 'windmove-up)
  (define-key my-keys-map (kbd "H-j") 'windmove-down)

  (setq framemove-hook-into-windmove t)

#+end_src
** yasnippet
#+begin_src emacs-lisp :tangle yes
  ;;(require 'yasnippet)
  (yas-global-mode 1)
  ;;(require 'dropdown-list)
  ;;(setq yas-prompt-functions
  ;;      '(yas-dropdown-prompt
  ;;        yas-ido-prompt
  ;;        yas-x-prompt
  ;;        yas-completing-prompt
  ;;        yas-no-prompt))

  ;;removes expanding with tab. Uses 'Auto-complete' instead
  ;;(define-key yas-minor-mode-map (kbd "<tab>") nil)
  ;;(define-key yas-minor-mode-map (kbd "TAB") nil)

#+end_src
** company
#+begin_src emacs-lisp :tangle yes
  (global-company-mode t)

  (defun eriks-company-command (ARG)
    (interactive "p")
    (cond
     ((= ARG 2)
      (call-interactively 'company-yasnippet))
     (t
      (call-interactively 'company-complete))))

  (define-key my-keys-map (kbd "C-SPC") 'eriks-company-command)

  (define-key company-active-map (kbd "<escape>") 'company-abort)

#+end_src
** undo-tree
#+begin_src emacs-lisp :tangle yes
  (global-undo-tree-mode 1)
  (global-set-key (kbd "C-z") 'undo)
  ;;(define-key my-keys-map (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'undo-tree-redo)
  ;;(define-key my-keys-map (kbd "C-S-z") 'undo-tree-redo)
  (define-key eriks-map (kbd "u") 'undo-tree-visualize)
#+end_src
** ivy and avy
#+begin_src emacs-lisp :tangle yes
  ;;ivy
  (ivy-mode 1)
  (counsel-mode 1)
  (global-set-key (kbd "C-s") 'swiper)
  ;; (global-set-key (kbd "M-x") 'counsel-M-x)
  ;;(global-set-key (kbd "C-x C-f") 'counsel-find-file)
  ;; (define-key my-keys-map [remap find-file] 'counsel-find-file)
  ;;(define-key ivy-minibuffer-map (kbd "<tab>") 'ivy-partial)

  ;;avy
  ;;(define-prefix-command 'eriks-avy-map)
  ;;(define-key my-keys-map (kbd "M-s") 'eriks-avy-map)
  ;;(global-set-key (kbd "M-s") 'avy-goto-char)
  (define-key eriks-map (kbd "SPC") 'avy-goto-char-in-line)
  (define-key eriks-map (kbd "S-SPC") 'avy-goto-char-timer)

  ;;dired
  ;;(add-hook 'dired-mode-hook
  ;;          (lambda ()
  ;;            (define-key dired-mode-map (kbd "M-s s") 'avy-goto-char)))
  (setq ivy-use-selectable-prompt t)

  (setq avy-keys (nconc
                  (number-sequence ?a ?z)
                  ;; '(?å ?ä ?ö)
                  ))
#+end_src
** golden ratio scroll
#+begin_src emacs-lisp :tangle yes
  (global-set-key [remap scroll-down-command] 'golden-ratio-scroll-screen-down)
  (global-set-key [remap scroll-up-command] 'golden-ratio-scroll-screen-up)
#+end_src
** projectile
#+begin_src emacs-lisp :tangle yes
  (projectile-global-mode t)
  (counsel-projectile-mode)
#+end_src
** dumb jump
#+begin_src emacs-lisp :tangle yes
  ;;(dumb-jump-mode)

  ;;(fset 'eriks-dumb-jump-keymap (make-sparse-keymap))
  (define-prefix-command 'eriks-dumb-jump-keymap)
  (define-key eriks-map (kbd "j") 'eriks-dumb-jump-keymap)

  (define-key 'eriks-dumb-jump-keymap (kbd "j") 'dumb-jump-go)
  (define-key 'eriks-dumb-jump-keymap (kbd "b") 'dumb-jump-back)

  (setq dumb-jump-selector 'ivy)

#+end_src
** multiple cursors
#+begin_src emacs-lisp :tangle yes
  ;; (asd-key '-map (kbd "m l") 'mc/edit-lines)
  ;; (asd-key '-map (kbd "m m") 'mc/mark-next-like-this)
  ;; (asd-key '-map (kbd "m n") 'mc/mark-previous-like-this)
  ;; (asd-key '-map (kbd "m b") 'mc/mark-all-like-this)
  (define-key mc/keymap (kbd "<return>") nil)

  (defhydra hydra-multiple-cursors (:color pink)
    "
       ^Up^            ^Down^        ^Other^
  ----------------------------------------------------------
  [_p_]   Next    [_n_]   Next    [_l_] Edit lines      [_R_] Region-anchor
  [_P_]   Skip    [_N_]   Skip    [_a_] Mark all        [_m_] put cursor at mark
  [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp  [_1_] Insert numbers
  ^ ^             ^ ^             [_q_] Quit            [_2_] Insert letters
  ^^C-v: next cursor, M-v: prev cursor, C-': only lines with cursors
  "
    ("l" mc/edit-lines nil :exit t)
    ("a" mc/mark-all-like-this nil :exit t)
    ("n" mc/mark-next-like-this nil)
    ("N" mc/skip-to-next-like-this nil)
    ("M-n" mc/unmark-next-like-this nil)
    ("p" mc/mark-previous-like-this nil)
    ("P" mc/skip-to-previous-like-this nil)
    ("M-p" mc/unmark-previous-like-this nil)
    ("r" mc/mark-all-in-region-regexp nil :exit t)
    ("R" set-rectangular-region-anchor nil :color blue)
    ("m" mc/mark-pop nil)
    ("1" mc/insert-numbers nil)
    ("2" mc/insert-letters nil)
    ("q" nil nil))
  (define-key 'eriks-map (kbd "m") 'hydra-multiple-cursors/body)
  (define-key my-keys-map (kbd "C-c m") 'hydra-multiple-cursors/body)
#+end_src
** smartparens
*** standard config
#+begin_src emacs-lisp :tangle yes
  (require 'smartparens-config)

  ;; (add-hook 'smartparens-strict-mode-hook (lambda ()
  ;;                                           (define-key smartparens-strict-mode-map [remap modalka-kill] 'modalka-sp-kill)
  ;;                                           (define-key smartparens-strict-mode-map [remap modalka-delete] 'modalka-sp-delete)))

  (defun start-smartparens ()
    (smartparens-mode t)
    (show-smartparens-mode t)

    (define-key smartparens-mode-map (kbd "C-M-SPC") 'sp-mark-sexp)

    (define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
    (define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

    (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)

    (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
    (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)

    (define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)

    ;;(define-key smartparens-mode-map (kbd "M-f") 'sp-forward-symbol)
    ;;(define-key smartparens-mode-map (kbd "M-b") 'sp-backward-symbol)

    )

  (defun start-hydra-smartparens-if-activated ()
    (interactive)
    (if (bound-and-true-p smartparens-mode)
        (hydra-smartparens/body)
      (message "smartparens not activated!")))

  (define-key eriks-map (kbd "p") 'hydra-smartparens/body) ;;'start-hydra-smartparens-if-activated

  (defhydra hydra-smartparens (:color blue)
    "
   ^forward^      ^backward^     ^Sexp^          ^Hybrid^
  ^^^^^^^^-----------------------------------------------------
   [_m_] : barf   [_i_] : slurp  [_K_] : kill    [_k_] : kill
   [_n_] : slurp  [_o_] : barf   [_s_] : splice  [_w_] : slurp
    ^ ^            ^ ^           [_S_] : split   [_e_] : barf
    ^ ^            ^ ^           [_J_] : join     ^ ^
  "
    ("K" sp-kill-sexp nil)
    ("s" sp-splice-sexp nil)
    ("S" sp-split-sexp nil)
    ("J" sp-join-sexp nil)
    ("m" sp-forward-barf-sexp nil)
    ("n" sp-forward-slurp-sexp nil)
    ("i" sp-backward-slurp-sexp nil)
    ("o" sp-backward-barf-sexp nil)
    ("k" sp-kill-hybrid-sexp nil)
    ("w" sp-slurp-hybrid-sexp nil)
    ("e" sp-dedent-adjust-sexp nil)
    )
  ;;("q" nil "Quit" :color blue)

#+end_src
*** parenthesis
#+begin_src emacs-lisp :tangle yes
  (defun my-create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))

  (sp-local-pair '(c-mode java-mode) "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
  ;;(sp-local-pair 'java-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))

#+end_src
** dashboard
#+begin_src emacs-lisp :tangle yes
  (require 'dashboard)
  (dashboard-setup-startup-hook)

  (setq dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)))
#+end_src
** outshine
#+begin_src emacs-lisp :tangle yes
  ;; (defvar outline-minor-mode-prefix "\M-#")
  (require 'outshine)
  (add-hook 'outline-minor-mode-hook (lambda ()
                                       (outshine-hook-function)
                                       (define-key outline-minor-mode-map [remap self-insert-command] nil) ;;remove annyoing remap to outshine-self-insert-command
                                       ))

  ;; removed top-level sexpressions as outlines in lisp modes
  (dolist (l-mode '(emacs-lisp-mode-hook lisp-mode-hook))
    (add-hook l-mode (lambda ()
                       (setq outline-regexp ";;;\\(;* [^ 	
  ]\\|###autoload\\)"))))

  ;; enable in some programming modes
  (dolist (p-mode '(emacs-lisp-mode-hook
                    lisp-mode-hook
                    c-mode-hook
                    java-mode-hook))
    (add-hook p-mode 'outline-minor-mode))

  ;; Narrowing now works within the headline rather than requiring to be on it
  (advice-add 'outshine-narrow-to-subtree :before
              (lambda (&rest args) (unless (outline-on-heading-p t)
                                     (outline-previous-visible-heading 1))))

  (evil-define-key '(normal visual motion) outline-minor-mode-map
    (kbd "SPC ou") 'outline-up-heading
    (kbd "SPC oj") 'outline-forward-same-level
    (kbd "SPC ok") 'outline-backward-same-level
    (kbd "SPC ol") 'outline-next-visible-heading
    (kbd "SPC oh") 'outline-previous-visible-heading
    (kbd "SPC on") 'outshine-narrow-to-subtree
    (kbd "SPC ow") 'widen
    (kbd "SPC oJ") 'outline-move-subtree-down
    (kbd "SPC oK") 'outline-move-subtree-up
    (kbd "SPC oH") 'outline-promote
    (kbd "SPC oL") 'outline-demote
    (kbd "SPC oi") 'outshine-insert-heading
    (kbd "SPC oc") 'outshine-cycle-buffer
    (kbd "SPC of") 'outline-hide-entry
    (kbd "SPC os") 'outline-show-entry
    )
#+end_src
** ibuffer
#+begin_src emacs-lisp :tangle yes
  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("dired" (mode . dired-mode))
                 ;;("perl" (mode . cperl-mode))
                 ;;("erc" (mode . erc-mode))
                 ;; ("planner" (or
                 ;;             (name . "^\\*Calendar\\*$")
                 ;;             (name . "^diary$")
                 ;;             (mode . muse-mode)))
                 ("emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")
                           (name . "^\\*dashboard\\*$")
                           (mode . help-mode)
                           (name . "^\\*Customize.*")))
                 ("magit" (name . "^\\*magit:.*"))
                 ;; ("gnus" (or
                 ;;          (mode . message-mode)
                 ;;          (mode . bbdb-mode)
                 ;;          (mode . mail-mode)
                 ;;          (mode . gnus-group-mode)
                 ;;          (mode . gnus-summary-mode)
                 ;;          (mode . gnus-article-mode)
                 ;;          (name . "^\\.bbdb$")
                 ;;          (name . "^\\.newsrc-dribble")))
                 ))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  (define-key my-keys-map (kbd "C-x C-b") 'ibuffer)
#+end_src
** ggtags
#+begin_src emacs-lisp :tangle yes
  (add-hook 'ggtags-mode-hook
            (lambda ()
              (setq ggtags-mode-line-project-name nil)))
#+end_src
** auctex
#+begin_src emacs-lisp :tangle yes

  (eval-after-load
      "latex"
    (progn
      (add-hook 'LaTeX-mode-hook
                (lambda ()
                  (modify-syntax-entry ?$ "\"" LaTeX-mode-syntax-table) ;;make $ act like string so smartparens can navigate with it.
                  (define-key LaTeX-mode-map [remap beginning-of-defun] 'LaTeX-find-matching-begin)
                  (define-key LaTeX-mode-map [remap end-of-defun] 'LaTeX-find-matching-end)
                  ;; (define-key LaTeX-mode-map (kbd "$") nil)
                  (run-hooks 'prog-mode-hook)
                  ;; (embrace-surround-latex-hook)
                  ))))


#+end_src
** evil
#+begin_src emacs-lisp :tangle yes
  (setq evil-emacs-state-modes
        (append
         evil-emacs-state-modes
         evil-motion-state-modes
         '(moccur-grep-mode)))
  (setq evil-motion-state-modes nil)

  (setq evil-emacs-state-cursor 'bar)

  (evil-indent-plus-default-bindings) ;;ii iI ai aI iJ aJ

  (define-key evil-emacs-state-map [escape] 'evil-normal-state)
  (evil-set-initial-state 'dired-mode 'emacs)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; evil remap ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun evil-remap (trigger action &optional map)
    "remaps a key sequence to execute another key sequence in evil-mode.

  'trigger' is the key sequence to \"remap\" to the key sequence 'action'.
  The map to bind 'trigger' in is by default `evil-normal-state-map' (evil normal mode).

  (evil-remap \"C-@\" \"@@\") will in normal mode, make C-@ virtually press @@ and run the latest keyboard macro (default behaviour). "
    (let ((mmap (if (null map) evil-normal-state-map map)))
      (define-key mmap (kbd trigger)
        `(lambda ()
           (interactive)
           (execute-kbd-macro ,action)))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; normal mode ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;(define-key evil-normal-state-map (kbd "RET") 'newline-without-break-down)
  ;;(define-key evil-normal-state-map (kbd "<S-return>") 'newline-without-break-up)

  (define-key evil-normal-state-map (kbd "M-k") 'drag-stuff-up)
  (define-key evil-normal-state-map (kbd "M-j") 'drag-stuff-down)
  (define-key evil-normal-state-map (kbd "M-h") 'drag-stuff-left)
  (define-key evil-normal-state-map (kbd "M-l") 'drag-stuff-right)
  (define-key evil-visual-state-map (kbd "M-k") 'drag-stuff-up)
  (define-key evil-visual-state-map (kbd "M-j") 'drag-stuff-down)
  (define-key evil-visual-state-map (kbd "M-h") 'drag-stuff-left)
  (define-key evil-visual-state-map (kbd "M-l") 'drag-stuff-right)
  ;; (define-key evil-normal-state-map (kbd "C-k") 'move-text-up)
  ;; (define-key evil-normal-state-map (kbd "C-j") 'move-text-down)
  ;; (define-key evil-visual-state-map (kbd "C-j") (concat ":m '>+1" (kbd "RET") "gv=gv"))
  ;; (define-key evil-visual-state-map (kbd "C-k") (concat ":m '<-2" (kbd "RET") "gv=gv"))

  (define-key evil-normal-state-map (kbd "<backspace>") 'evil-ex-nohighlight)

  (evil-remap "C-@" "@@")

  (defun evil-capitalize-last-word ()
    (interactive)
    (save-excursion
      ;; (evil-backward-word-end)
      (let ((end (point)))
        (evil-backward-word-begin)
        (eriks-evil-capitalize-operator (point) end))))

  (define-key evil-insert-state-map (kbd "M-c") 'evil-capitalize-last-word)
  (define-key my-keys-map (kbd "M-c") 'evil-capitalize-last-word)

  (defun evil-open-line ()
    "open-line for evil, designed to be the opposite of J (join-lines).

  Indents the new line if it is not empty. If the current major mode is
  derived from prog-mode, then `indent-according-to-mode' is used,
  otherwise the current line's indentation is used.

  Assumes `left-margin' is 0 or that there is no fill prefix (that
  open-line doesn't indent the new line in any way)"
    (interactive)
    (let ((start-ind (current-indentation)))
      (just-one-space 0)
      (open-line 1)
      (save-excursion
        (forward-char)
        (unless (eolp)
          (if (derived-mode-p 'prog-mode)
              (indent-according-to-mode)
            (indent-to start-ind))))))

  ;;opposite to J (join-lines)
  (define-key evil-normal-state-map (kbd "S") 'evil-open-line)
  ;; (define-key evil-normal-state-map (kbd "S")
  ;;   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([100 105 32 134217848 111 112 101 110 45 108 105 110 101 return] 0 "%d")) arg)))

  ;; (define-key evil-normal-state-map (kbd "g o")
  ;;   (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ("Sl==[ " 0 "%d")) arg)))

  (define-key evil-normal-state-map (kbd "ga") 'evil-lion-left)
  (define-key evil-normal-state-map (kbd "gA") 'evil-lion-right)

  (define-key evil-normal-state-map (kbd "U")   'undo-tree-redo)
  (define-key evil-normal-state-map (kbd "C-d") 'golden-ratio-scroll-screen-up)
  (define-key evil-normal-state-map (kbd "C-u") 'golden-ratio-scroll-screen-down)

  (define-key evil-normal-state-map (kbd "C-w") 'hydra-windows/body)

  (define-key evil-normal-state-map (kbd "M--") 'evil-numbers/dec-at-pt)
  (define-key evil-normal-state-map (kbd "M-+") 'evil-numbers/inc-at-pt)

  (define-key evil-normal-state-map (kbd "gtc") 'transpose-chars)
  (define-key evil-normal-state-map (kbd "gtl") 'transpose-lines)
  (define-key evil-normal-state-map (kbd "gtw") 'transpose-words)
  (define-key evil-normal-state-map (kbd "gts") 'subword-transpose)
  (define-key evil-normal-state-map (kbd "gt C-l") 'subword-transpose)
  (define-key evil-normal-state-map (kbd "gtr") 'eriks-region-switch)
  (define-key evil-normal-state-map (kbd "gtR") 'eriks-region-switch-abort)

  (define-key evil-normal-state-map (kbd "M-u") 'universal-argument)
  (define-key evil-insert-state-map (kbd "M-u") 'universal-argument)
  (define-key evil-visual-state-map (kbd "M-u") 'universal-argument)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; nerd commenter ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'evil-nerd-commenter)

  (define-key evil-normal-state-map (kbd "gc") 'evilnc-comment-operator)
  (define-key evil-normal-state-map (kbd "gC") 'evilnc-copy-and-comment-operator)

  (define-key evil-inner-text-objects-map (kbd "c") 'evilnc-inner-comment)
  (define-key evil-outer-text-objects-map (kbd "c") 'evilnc-outer-commenter)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; extra operator ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'evil-extra-operator)

  (define-key evil-normal-state-map (kbd "gr") 'evil-operator-eval)

  (defun search-online (website search)
    (interactive "sWebsite: \nsQuery: ")
    (browse-url
     (concat website (url-hexify-string search))))

  (defun search-online-google (search)
    (interactive "sSearch: ")
    (search-online "http://google.com/search?q=" search))

  (define-key evil-normal-state-map (kbd "SPC s G") 'search-online-google)

  (defun search-online-javadoc (search)
    (interactive "sSearch: ")
    (search-online "http://javadocs.org/" search))

  (define-key evil-normal-state-map (kbd "SPC s J") 'search-online-javadoc)

  (evil-define-operator eriks-evil-javadoc-search-operator (beg end type)
    "Evil operator for javadoc search."
    :move-point nil
    (interactive "<R>")
    (browse-url
     (concat "http://javadocs.org/"
             (url-hexify-string
              (.eeo/make-url-args beg end type)))))

  (define-key evil-normal-state-map (kbd "SPC s g") 'evil-operator-google-search)
  (define-key evil-normal-state-map (kbd "SPC s j") 'eriks-evil-javadoc-search-operator)
  (define-key evil-visual-state-map (kbd "SPC s g") 'evil-operator-google-search)
  (define-key evil-visual-state-map (kbd "SPC s j") 'eriks-evil-javadoc-search-operator)

  (evil-define-operator eriks-evil-swiper-operator (beg end type)
    (interactive "<R>")
    (when (evil-visual-state-p)
      (evil-exit-visual-state))
    (swiper (buffer-substring beg end)))

  (evil-define-operator eriks-evil-capitalize-operator (beg end type)
    (interactive "<R>")
    (when (evil-visual-state-p)
      (evil-exit-visual-state))
    (capitalize-region beg end))

  (define-key evil-normal-state-map (kbd "g C-u") 'eriks-evil-capitalize-operator)
  (define-key evil-visual-state-map (kbd "g C-u") 'eriks-evil-capitalize-operator)
  (define-key evil-visual-state-map (kbd "M-c") 'eriks-evil-capitalize-operator)
  (define-key evil-normal-state-map (kbd "M-c") 'eriks-evil-capitalize-operator)

  ;; (define-key evil-normal-state-map (kbd "g o") 'eriks-evil-capitalize-operator)
  ;; (define-key evil-visual-state-map (kbd "g o") 'eriks-evil-capitalize-operator)

  (define-key evil-normal-state-map (kbd "SPC s s") 'eriks-evil-swiper-operator)
  (define-key evil-visual-state-map (kbd "SPC s s") 'eriks-evil-swiper-operator)

  (define-key evil-normal-state-map (kbd "SPC s S") 'swiper)

  (define-key evil-normal-state-map (kbd "gp") 'evil-operator-clone)
  (define-key evil-visual-state-map (kbd "gp") 'evil-operator-clone)

  (require 'evil-little-word)
  (define-key evil-motion-state-map (kbd "C-l C-w") 'evil-forward-little-word-begin)
  (define-key evil-motion-state-map (kbd "C-l C-b") 'evil-backward-little-word-begin)
  (define-key evil-motion-state-map (kbd "C-l C-S-w") 'evil-forward-little-word-end)
  (define-key evil-motion-state-map (kbd "C-l C-e") 'evil-forward-little-word-end)
  (define-key evil-motion-state-map (kbd "C-l C-S-b") 'evil-backward-little-word-end)
  (define-key evil-motion-state-map (kbd "C-l w") 'evil-forward-little-word-begin)
  (define-key evil-motion-state-map (kbd "C-l b") 'evil-backward-little-word-begin)
  (define-key evil-motion-state-map (kbd "C-l W") 'evil-forward-little-word-end)
  (define-key evil-motion-state-map (kbd "C-l e") 'evil-forward-little-word-end)
  (define-key evil-motion-state-map (kbd "C-l B") 'evil-backward-little-word-end)
  (define-key evil-outer-text-objects-map (kbd "C-l") 'evil-a-little-word)
  (define-key evil-inner-text-objects-map (kbd "C-l") 'evil-inner-little-word)

  (define-key evil-normal-state-map (kbd "SPC s M") 'dmoccur)
  (define-key evil-normal-state-map (kbd "SPC s N") 'moccur)
  (define-key evil-normal-state-map (kbd "SPC s O") 'occur-by-moccur)

  (define-key evil-normal-state-map (kbd "SPC s a p") 'projectile-ag)
  (define-key evil-normal-state-map (kbd "SPC s a c") 'counsel-ag)
  (define-key evil-normal-state-map (kbd "SPC s a a") 'ag)
  (define-key evil-normal-state-map (kbd "SPC s a r") 'ag-regexp)
  (define-key evil-normal-state-map (kbd "SPC s a R") 'ag-project-regexp)
  (define-key evil-normal-state-map (kbd "SPC s a P") 'ag-project)

  (setq evil-operator-moccur-grep-find-key (kbd "SPC s m"))
  (require 'evil-operator-moccur)
  (global-evil-operator-moccur-mode 1)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; evil surround ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'evil-surround)
  (global-evil-surround-mode 1)

  (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)
  (evil-define-key 'visual evil-surround-mode-map "S" 'evil-Surround-region)
  (evil-define-key 'normal evil-surround-mode-map "gs" 'evil-surround-edit)
  (evil-define-key 'normal evil-surround-mode-map "gS" 'evil-Surround-edit)

  ;;make global inner and outer text objects with specified start delimeter and end delimeter.
  (defmacro define-and-bind-text-object-global (key start-regex end-regex)
    (let ((inner-name (make-symbol "inner-name"))
          (outer-name (make-symbol "outer-name")))
      `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-inner-text-objects-map (kbd ,key) (quote ,inner-name))
         (define-key evil-outer-text-objects-map (kbd ,key) (quote ,outer-name)))))

  ;;make local inner and outer text objects with specified start
  ;;delimeter and end delimeter. binds key buffer locally by binding it
  ;;to `evil-operator-state-local-map'. This will work for any
  ;;case except for evil-surround delete and change (or any other
  ;;function/package that uses evil-(inner/outer)-state-map internally).
  ;;For that to work the local map has to get its global counterpart as
  ;;parent (do this in mode hook), and a change in evil-surround.el (or
  ;;corresponding function/package) has to be made to use the local
  ;;version instead.
  (defmacro define-and-bind-text-object-local (key start-regex end-regex)
    (let ((inner-name (make-symbol "inner-name"))
          (outer-name (make-symbol "outer-name")))
     `(progn
         (evil-define-text-object ,inner-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count nil))
         (evil-define-text-object ,outer-name (count &optional beg end type)
           (evil-select-paren ,start-regex ,end-regex beg end type count t))
         (define-key evil-visual-state-local-map   (kbd (format "i %s" ,key)) (quote ,inner-name)) ;;TODO: extract these
         (define-key evil-operator-state-local-map (kbd (format "i %s" ,key)) (quote ,inner-name))
         (define-key evil-visual-state-local-map   (kbd (format "a %s" ,key)) (quote ,outer-name))
         (define-key evil-operator-state-local-map (kbd (format "a %s" ,key)) (quote ,outer-name)))))

  (defun erik-evil-surround-advice ()
    (set-keymap-parent evil-operator-state-local-map evil-operator-state-map) ;makes evil-surround find non-buffer-local text objects (required to change in evil-surround.el)
    )
  (advice-add 'evil-initialize-local-keymaps :after 'erik-evil-surround-advice)

  ; generic ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (evil-define-text-object erik-evil-generic-outer-text-object (count &optional beg end type)
    (let ((text (read-from-minibuffer "" "")))
      (if erik-evil-generic-outer
          (setq erik-evil-generic-latest text))
      (evil-select-paren text text beg end type count t)))

  (evil-define-text-object erik-evil-generic-inner-text-object (count &optional beg end type)
    (let ((text (if (and erik-evil-generic-inner
                         erik-evil-generic-latest)
                    erik-evil-generic-latest
                  (read-from-minibuffer "" ""))))
      ;; (setq erik-evil-generic-inner nil)
      (evil-select-paren text text beg end type count nil)))

  (define-key evil-inner-text-objects-map (kbd "g") 'erik-evil-generic-inner-text-object)
  (define-key evil-outer-text-objects-map (kbd "g") 'erik-evil-generic-outer-text-object)

  (defun erik-evil-surround-generic ()
    (let ((text (read-from-minibuffer "" "")))
      (cons text text)))

  (setq-default evil-surround-pairs-alist (cons '(?g . erik-evil-surround-generic) evil-surround-pairs-alist))

  ;;stop evil-surround from asking for the same text twice
  (setq erik-evil-generic-inner nil)
  (setq erik-evil-generic-outer nil)
  (setq erik-evil-generic-latest nil)

  (defun erik-evil-generic-before-outer (char)
    (setq erik-evil-generic-outer t))

  (defun erik-evil-generic-after-outer (char)
    (setq erik-evil-generic-outer nil))

  (advice-add 'evil-surround-outer-overlay :before 'erik-evil-generic-before-outer)
  (advice-add 'evil-surround-outer-overlay :after 'erik-evil-generic-after-outer)

  (defun erik-evil-generic-before-inner (char)
    (setq erik-evil-generic-inner t))

  (defun erik-evil-generic-after-inner (char)
    (setq erik-evil-generic-inner nil))

  (advice-add 'evil-surround-inner-overlay :before 'erik-evil-generic-before-inner)
  (advice-add 'evil-surround-inner-overlay :after 'erik-evil-generic-after-inner)

  ;; between ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (evil-define-text-object erik-evil-between-outer-text-object (count &optional beg end type)
  ;;   (let ((text (evil-read-key)))
  ;;     (if erik-evil-generic-outer
  ;;         (setq erik-evil-generic-latest text))
  ;;     (evil-select-paren text text beg end type count t)))

  ;; (evil-define-text-object erik-evil-between-inner-text-object (count &optional beg end type)
  ;;   (let ((text (if (and erik-evil-generic-inner
  ;;                        erik-evil-generic-latest)
  ;;                   erik-evil-generic-latest
  ;;                 (evil-read-key))))
  ;;     (evil-select-paren text text beg end type count nil)))

  ;; (define-key evil-inner-text-objects-map (kbd "b") 'erik-evil-between-inner-text-object) ;;vib" -- gives weird behaviour when inner is only one character long
  ;; (define-key evil-outer-text-objects-map (kbd "b") 'erik-evil-between-outer-text-object)

  (setq evil-textobj-between-a-key "b")
  (setq evil-textobj-between-i-key "b")
  (require 'evil-textobj-between)

  (defun erik-evil-surround-between-cmd ()
    (let ((text (string (read-char))))
      (cons text text)))

  (setq-default evil-surround-pairs-alist (cons '(?b . erik-evil-surround-between-cmd) evil-surround-pairs-alist))

  ;; global ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (define-and-bind-text-object-global "f" "\\_<[a-bA-b0-9._-]+?(" ")")

  ;; latex ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun erik-evil-surround-latex-cmd ()
    (let ((text (read-from-minibuffer "" "")))
      (cons (concat "\\" text "{") "}")))

  (sp-local-pair '(tex-mode plain-tex-mode latex-mode LaTeX-mode) "$" "$")

  (defun erik-evil-surround-latex-hook ()
    (setq evil-surround-pairs-alist (cons '(?f . erik-evil-surround-latex-cmd) evil-surround-pairs-alist))
    (define-and-bind-text-object-local "f" "\\\\[a-bA-b0-9._-]+?{" "}")
    (define-and-bind-text-object-local "$" "\\$" "\\$"))

  (dolist (hk '(tex-mode-hook plain-tex-mode-hook latex-mode-hook LaTeX-mode-hook))
    (add-hook hk 'erik-evil-surround-latex-hook))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; visual mode ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (define-key evil-visual-state-map (kbd "gx") 'exchange-point-and-mark)

  ;; (evil-remap "g C-n" "\\rN1%d" evil-visual-state-map)

  (defun eriks-evil-visual-block-insert (start padding format)
    (save-excursion
      (evil-emacs-state nil)
      (rectangle-number-lines
       (region-beginning)
       (region-end)
       start
       (format format
               (cond
                ((= padding 0)
                 "")
                (t
                 (number-to-string (- 0 padding))))))
      (evil-normal-state)))

  (defun eriks-evil-visual-block-insert-numbers-zero (padding)
    (interactive "p")
    (eriks-evil-visual-block-insert 1 padding "%%0%sd"))

  (defun eriks-evil-visual-block-insert-numbers (padding)
    (interactive "p")
    (eriks-evil-visual-block-insert 1 padding "%%%sd"))

  (defun eriks-evil-visual-block-insert-letters (padding)
    (interactive "p")
    (eriks-evil-visual-block-insert 97 padding "%%%sc"))

  (defun eriks-evil-visual-block-insert-alt ()
    (interactive)
    (setq current-prefix-arg '(4))
    (call-interactively 'rectangle-number-lines))

  (define-key evil-visual-state-map (kbd "SPC i n") 'eriks-evil-visual-block-insert-numbers)
  (define-key evil-visual-state-map (kbd "SPC i N") 'eriks-evil-visual-block-insert-numbers-zero)
  (define-key evil-visual-state-map (kbd "SPC i l") 'eriks-evil-visual-block-insert-letters)
  (define-key evil-visual-state-map (kbd "SPC i i") 'eriks-evil-visual-block-insert-alt)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; space key ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; (define-prefix-command 'evil-spc)
  ;; (define-key evil-normal-state-map (kbd "SPC") 'evil-spc)
  ;;(define-key evil-visual-state-map (kbd "SPC") 'evil-spc)

  (define-key evil-normal-state-map (kbd "SPC M-+") 'hydra-evil-numbers/body)

  ;;(define-key evil-spc (kbd ";") 'comment-dwim)

  (define-key evil-normal-state-map (kbd "SPC u") 'undo-tree-visualize)
  (define-key evil-normal-state-map (kbd "SPC .") 'repeat)

  (define-key evil-normal-state-map (kbd "SPC p]") 'sp-forward-slurp-sexp)
  (define-key evil-normal-state-map (kbd "SPC p[") 'sp-backward-slurp-sexp)
  (define-key evil-normal-state-map (kbd "SPC p}") 'sp-forward-barf-sexp)
  (define-key evil-normal-state-map (kbd "SPC p{") 'sp-backward-barf-sexp)
  (define-key evil-normal-state-map (kbd "SPC ps") 'sp-split-sexp)
  (define-key evil-normal-state-map (kbd "SPC pj") 'sp-join-sexp)
  (define-key evil-normal-state-map (kbd "SPC pt") 'sp-transpose-sexp)

  (define-key evil-normal-state-map (kbd "H-]") 'sp-forward-slurp-sexp)
  (define-key evil-normal-state-map (kbd "H-[") 'sp-backward-slurp-sexp)
  (define-key evil-normal-state-map (kbd "H-}") 'sp-forward-barf-sexp)
  (define-key evil-normal-state-map (kbd "H-{") 'sp-backward-barf-sexp)

  ;; (define-key evil-spc (kbd "c") 'eriks-duplicate-line)

  (define-key evil-normal-state-map (kbd "SPC y") 'browse-kill-ring)
  (define-key evil-normal-state-map (kbd "SPC Y") 'counsel-yank-pop)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; insert motion ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (define-key evil-insert-state-map (kbd "C-^") 'sp-up-sexp)
  (define-key evil-insert-state-map (kbd "C-e") 'end-of-line)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; space motion ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (require 'evil-easymotion)
  (evilem-default-keybindings "SPC")

  (define-key evil-motion-state-map (kbd ",") 'avy-goto-char-in-line)
  (define-key evil-motion-state-map (kbd "SPC SPC") 'avy-goto-char-in-line)
  (evil-declare-not-repeat 'avy-goto-char-in-line)

  (define-key evil-motion-state-map (kbd ";") 'avy-goto-char)

  (define-key evil-motion-state-map (kbd "SPC /") 'avy-goto-char-timer)
  (evil-declare-not-repeat 'avy-goto-char-timer)

  (define-key evil-motion-state-map (kbd "C-;") 'evil-repeat-find-char)
  (define-key evil-motion-state-map (kbd "C-,") 'evil-repeat-find-char-reverse)
  (define-key evil-motion-state-map (kbd "H-.") 'evil-repeat-find-char)
  (define-key evil-motion-state-map (kbd "H-,") 'evil-repeat-find-char-reverse)

  (evilem-define (kbd "SPC ][") 'sp-next-sexp)
  (evilem-define (kbd "SPC ]]") 'sp-forward-sexp)
  (evilem-define (kbd "SPC [[") 'sp-backward-sexp)
  (evilem-define (kbd "SPC []") 'sp-previous-sexp)

  (evilem-define (kbd "SPC {") 'sp-backward-up-sexp)
  (evilem-define (kbd "SPC }") 'sp-up-sexp)
  (evilem-define (kbd "SPC M-[") 'sp-backward-down-sexp)
  (evilem-define (kbd "SPC M-]") 'sp-down-sexp)
  (evilem-define (kbd "SPC (") 'sp-beginning-of-sexp)
  (evilem-define (kbd "SPC )") 'sp-end-of-sexp)

  (evilem-define (kbd "SPC ]s") 'forward-sentence)
  (evilem-define (kbd "SPC [s") 'backward-sentence)
  (evilem-define (kbd "SPC ]p") 'forward-paragraph)
  (evilem-define (kbd "SPC [p") 'backward-paragraph)

  (evilem-define (kbd "SPC [i") 'eriks-up-indentation)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; motion map ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (define-key evil-motion-state-map (kbd "[m") 'evil-backward-section-begin)
  (define-key evil-motion-state-map (kbd "[M") 'evil-backward-section-end)
  (define-key evil-motion-state-map (kbd "]m") 'evil-forward-section-begin)
  (define-key evil-motion-state-map (kbd "]M") 'evil-forward-section-end)

  (evil-remap "[<" "F<" evil-motion-state-map)
  (evil-remap "[>" "F>" evil-motion-state-map)
  (evil-remap "]<" "f<" evil-motion-state-map)
  (evil-remap "]>" "f>" evil-motion-state-map)

  (define-key evil-motion-state-map (kbd "]s") 'forward-sentence)
  (define-key evil-motion-state-map (kbd "[s") 'backward-sentence)
  (define-key evil-motion-state-map (kbd "]p") 'forward-paragraph)
  (define-key evil-motion-state-map (kbd "[p") 'backward-paragraph)

  (define-key evil-motion-state-map (kbd "][") 'sp-next-sexp)
  (define-key evil-motion-state-map (kbd "]]") 'sp-forward-sexp)
  (define-key evil-motion-state-map (kbd "[[") 'sp-backward-sexp)
  (define-key evil-motion-state-map (kbd "[]") 'sp-previous-sexp)

  (define-key evil-motion-state-map (kbd "[d") 'beginning-of-defun)
  (define-key evil-motion-state-map (kbd "]d") 'end-of-defun)

  (define-key evil-motion-state-map (kbd "[i") 'eriks-up-indentation)

  (define-key evil-motion-state-map (kbd "[c") 'eriks-up-same-column)
  (define-key evil-motion-state-map (kbd "]c") 'eriks-down-same-column)

  (define-key evil-motion-state-map (kbd "[ SPC") 'eriks-skip-space-backwards)
  (define-key evil-motion-state-map (kbd "] SPC") 'eriks-skip-space)

  (define-key evil-motion-state-map (kbd "{") 'sp-backward-up-sexp)
  (define-key evil-motion-state-map (kbd "}") 'sp-up-sexp)
  (define-key evil-motion-state-map (kbd "M-[") 'sp-backward-down-sexp)
  (define-key evil-motion-state-map (kbd "M-]") 'sp-down-sexp)
  (define-key evil-motion-state-map (kbd "(") 'sp-beginning-of-sexp)
  (define-key evil-motion-state-map (kbd ")") 'sp-end-of-sexp)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; multiple cursors ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defvar evil-mc-key-map
    (let ((map (make-sparse-keymap))
          (keys '(("gmm"   . evil-mc-make-all-cursors)
                  ("gmu"   . evil-mc-undo-all-cursors)
                  ("gms"   . evil-mc-pause-cursors)
                  ("gmr"   . evil-mc-resume-cursors)
                  ("gmf"   . evil-mc-make-and-goto-first-cursor)
                  ("gml"   . evil-mc-make-and-goto-last-cursor)
                  ("gmh"   . evil-mc-make-cursor-here)
                  ("gmj"   . evil-mc-make-cursor-move-next-line)
                  ("gmk"   . evil-mc-make-cursor-move-prev-line)
                  ("C-S-n" . evil-mc-make-cursor-move-next-line)
                  ("C-S-p" . evil-mc-make-cursor-move-prev-line)
                  ("gmN"   . evil-mc-skip-and-goto-next-cursor)
                  ("gmP"   . evil-mc-skip-and-goto-prev-cursor)
                  ("gmn"   . evil-mc-skip-and-goto-next-match)
                  ("gmp"   . evil-mc-skip-and-goto-prev-match)
                  ("M-n"   . evil-mc-make-and-goto-next-cursor)
                  ("M-p"   . evil-mc-make-and-goto-prev-cursor)
                  ("C-n"   . evil-mc-make-and-goto-next-match)
                  ("C-p"   . evil-mc-make-and-goto-prev-match)
                  ("gm+"   . evil-mc-inc-num-at-each-cursor)
                  ("gm-"   . evil-mc-dec-num-at-each-cursor)
                  ;; ("C-S-t" . evil-mc-skip-and-goto-next-match)
                  )))
      (dolist (key-data keys)
        (evil-define-key 'normal map (kbd (car key-data)) (cdr key-data))
        (evil-define-key 'visual map (kbd (car key-data)) (cdr key-data)))
      map))

  (setq evil-mc-one-cursor-show-mode-line-text nil)
  (setq evil-mc-mode-line-text-cursor-color nil)
  (setq evil-mc-mode-line-text-inverse-colors nil)
  (setq evil-mc-mode-line-text-cursor-color nil)
  (require 'evil-mc)
  (require 'evil-mc-extras)

  (add-to-list 'evil-mc-known-commands '(evil-surround-edit (:default . evil-mc-execute-default-evil-surround-region)))

  (dolist (cmd '(eval-last-sexp-replace
                 sp-end-of-sexp
                 sp-beginning-of-sexp
                 sp-up-sexp
                 sp-backward-up-sexp
                 sp-down-sexp
                 sp-backward-down-sexp))
    (add-to-list 'evil-mc-known-commands `(,cmd (:default . ,cmd))))

  ;; Temporary fix for bug with change command with multiple cursors
  ;; https://github.com/gabesoft/evil-mc/issues/63
  (add-hook 'evil-mc-before-cursors-created (lambda () (setq-default evil-move-cursor-back t)))
  (add-hook 'evil-mc-after-cursors-deleted (lambda () (setq-default evil-move-cursor-back nil)))

  (global-evil-mc-mode 1)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ggtags ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (evil-define-key 'normal ggtags-mode-map (kbd "C-]") 'ggtags-find-tag-dwim)
  (evil-define-key 'normal ggtags-mode-map (kbd "C-o") 'ggtags-prev-mark)
  (evil-define-key 'normal ggtags-mode-map (kbd "C-i") 'ggtags-next-mark)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; other ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (evil-define-text-object eriks-evil-inside-line-text-object (count &optional beg end type)
    (save-excursion
      (evil-first-non-blank)
      (let ((first (point)))
        (evil-end-of-line)
        (evil-range first (point)))))

  (evil-define-text-object eriks-evil-outside-line-text-object (count &optional beg end type)
    (save-excursion
      (move-beginning-of-line nil)
      (let ((first (point)))
        (evil-end-of-line)
        (evil-range first (point)))))

  (define-key evil-inner-text-objects-map (kbd "l") 'eriks-evil-inside-line-text-object)
  (define-key evil-outer-text-objects-map (kbd "l") 'eriks-evil-outside-line-text-object)

  (evil-define-text-object eriks-evil-inside-whitespace-text-object (count &optional beg end type)
    (save-excursion
      (eriks-skip-space -1 t)
      (let ((first (point)))
        (eriks-skip-space 1 t)
        (evil-range first (point)))))

  (evil-define-text-object eriks-evil-outside-whitespace-text-object (count &optional beg end type)
    (save-excursion
      (eriks-skip-space -1 nil)
      (let ((first (point)))
        (eriks-skip-space 1 nil)
        (evil-range first (point)))))

  (define-key evil-inner-text-objects-map (kbd "SPC") 'eriks-evil-inside-whitespace-text-object)
  (define-key evil-outer-text-objects-map (kbd "SPC") 'eriks-evil-outside-whitespace-text-object)

  (evil-define-text-object eriks-evil-inside-defun-text-object (count &optional beg end type)
    (save-excursion
      (beginning-of-defun)
      (let ((first (point)))
        (end-of-defun)
        (evil-range first (point)))))

  (define-key evil-inner-text-objects-map (kbd "d") 'eriks-evil-inside-defun-text-object)


  (evil-define-text-object erik-evil-inner-form-text-object (count &optional beg end type)
    (save-excursion
      (sp-beginning-of-sexp)
      (let ((first (point)))
        (sp-end-of-sexp)
        (evil-range first (point)))))

  (evil-define-text-object erik-evil-outer-form-text-object (count &optional beg end type)
    (save-excursion
      (let ((start (point)))
        (sp-backward-up-sexp)
        (let ((first (point)))
          (goto-char start)
          (sp-up-sexp)
          (evil-range first (point))))))

  (defun erik-evil-top-form-up (cursor)
    (interactive "d")
    (ignore-errors
      (sp-backward-up-sexp))
    (unless (= cursor (point))
        (erik-evil-top-form-up (point))))

  (defun erik-evil-top-form-end (cursor)
    (interactive "d")
    (erik-evil-top-form-up cursor)
    (sp-forward-sexp))

  (define-key evil-motion-state-map (kbd "g{") 'erik-evil-top-form-up)
  (define-key evil-motion-state-map (kbd "g}") 'erik-evil-top-form-end)

  (evil-define-text-object erik-evil-outer-top-form-text-object (count &optional beg end type)
    (save-excursion
      (erik-evil-top-form-up (point))
      (let ((first (point)))
        (sp-forward-sexp)
        (evil-range first (point)))))

  (evil-define-text-object erik-evil-inner-top-form-text-object (count &optional beg end type)
    (save-excursion
      (erik-evil-top-form-up (point))
      (let ((first (point)))
        (sp-forward-sexp)
        (let ((end (point)))
          (goto-char first)
          (sp-down-sexp)
          (let ((actual-first (point)))
            (goto-char end)
            (sp-backward-down-sexp)
            (evil-range actual-first (point)))))))

  (define-key evil-outer-text-objects-map (kbd "e") 'erik-evil-outer-form-text-object)
  (define-key evil-inner-text-objects-map (kbd "e") 'erik-evil-inner-form-text-object)
  (define-key evil-outer-text-objects-map (kbd "E") 'erik-evil-outer-top-form-text-object)
  (define-key evil-inner-text-objects-map (kbd "E") 'erik-evil-inner-top-form-text-object)

  ;; (require 'evil-cleverparens-text-objects)

  ;; (define-key evil-inner-text-objects-map (kbd "e") 'evil-cp-inner-form)
  ;; (define-key evil-outer-text-objects-map (kbd "e") 'evil-cp-a-form)
  ;; (define-key evil-inner-text-objects-map (kbd "E") 'evil-cp-inner-defun)
  ;; (define-key evil-outer-text-objects-map (kbd "E") 'evil-cp-a-defun)

  ;; fastnar i infinite loop ibland
  ;; (defun eriks-down-indentation ()
  ;;   (interactive)
  ;;   (back-to-indentation)
  ;;   (let ((start (current-column)))
  ;;     (while (= (current-column) start)
  ;;       (forward-line 1)
  ;;       (back-to-indentation))))

  (evil-mode 1)


#+end_src
** git gutter
#+begin_src emacs-lisp :tangle yes
  (setq git-gutter-fr+-side 'right-fringe)
  (require 'git-gutter-fringe+)

  (set-face-foreground 'git-gutter-fr+-modified "yellow")
  (set-face-background 'git-gutter-fr+-modified "yellow")

  (set-face-foreground 'git-gutter-fr+-deleted "red")
  (set-face-background 'git-gutter-fr+-deleted "red")

  (set-face-foreground 'git-gutter-fr+-added "green")
  (set-face-background 'git-gutter-fr+-added "green")

  ;; (fringe-helper-define 'git-gutter-fr+-modified nil
  ;;   "XXXXXXXX"
  ;;   "XXXXXXXX"
  ;;   "........"
  ;;   "........"
  ;;   "........"
  ;;   "........"
  ;;   "XXXXXXXX"
  ;;   "XXXXXXXX"
  ;;   )

  (global-git-gutter+-mode 1)
  ;; (git-gutter+-toggle-fringe)

  (define-key eriks-map (kbd "gg") 'git-gutter+-mode) ; Turn on/off in the current buffer
  (define-key eriks-map (kbd "gG") 'global-git-gutter+-mode) ; Turn on/off globally
  (define-key eriks-map (kbd "gj") 'git-gutter+-next-hunk)
  (define-key eriks-map (kbd "gk") 'git-gutter+-previous-hunk)
#+end_src
* prog-mode-hook
** prog-mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook
            (lambda ()
              (evil-set-initial-state major-mode 'normal)
              (make-local-variable 'newline-without-break-tab)
              (setq newline-without-break-tab t)
              ;;(autopair-mode 1)
              ;;(paredit-mode t)
              (start-smartparens)
              (setq show-trailing-whitespace t)
              (rainbow-delimiters-mode t)
              ;;(toggle-modalka 1)
              (add-todo-font-lock)))
#+end_src
** C-like modes
*** common
#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook
              (lambda ()
                (run-hooks 'abbrev-mode-hook) ;;för att den inte verkar göra det själv
                (setq-local comment-start "//")
                (setq-local comment-end "")

                ;;hs-minor-mode (hideShow)

                ;;(add-to-list 'ac-sources 'ac-source-c-headers)
                ;;(add-to-list 'ac-sources 'ac-source-c-header-symbols t)
                ;; (define-key c-mode-base-map (kbd "<C-S-return>")
                ;;   (lambda ()
                ;;     (interactive)
                ;;     (newline-without-break-up t)))

                ;; (define-key c-mode-base-map (kbd "<C-return>")
                ;;   (lambda ()
                ;;     (interactive)
                ;;     (newline-without-break-down t)))

                ;;(electric-pair-mode 1)
                ;;(make-local-variable 'newline-without-break-tab)
                ;;(setq newline-without-break-tab t)
                ;;(autopair-mode)
                ;;(setq show-trailing-whitespace t)
                ))

#+end_src
*** c
#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-hook
            (lambda ()
              (flycheck-mode 1)
              (ggtags-mode 1)
              ))
#+end_src
*** java
#+begin_src emacs-lisp :tangle yes
  (require 'eclim)
  (setq eclimd-autostart nil)

  (require 'company-emacs-eclim)
  (company-emacs-eclim-setup)

  (custom-set-variables
   '(eclim-eclipse-dirs '("~/bin/eclipse-neon"))
   '(eclim-executable "~/bin/eclipse-neon/eclim"))

  (setq help-at-pt-display-when-idle t)
  (setq help-at-pt-timer-delay 0.1)
  (help-at-pt-set-timer)

  (add-hook 'eclim-mode-hook
            (lambda ()
              (define-key eclim-mode-map (kbd "C-c C-e C-b") 'eclim-project-build)
              (define-key eclim-mode-map (kbd "C-c C-e d") nil)
              (define-key eclim-mode-map (kbd "C-c C-e d d") 'eclim-java-show-documentation-for-current-element)
              (define-key eclim-mode-map (kbd "C-c C-e d f") 'eclim-java-browse-documentation-at-point)
              (define-key eclim-mode-map (kbd "C-c C-e d s") 'eclim-java-doc-comment)
              ))

  (add-hook 'java-mode-hook
            (lambda ()
              (evil-define-key 'normal eclim-mode-map (kbd "C-]") 'eclim-java-find-declaration)))

  ;; (defun eclim-java-start ()
  ;;   (interactive)
  ;;   (eclim-mode t)
  ;;   ;; (require 'ac-emacs-eclim)
  ;;   ;;(ac-emacs-eclim-config)
  ;;   ;; (ac-emacs-eclim-java-setup)
  ;;   )

  ;; (defun start-eclim-if-inside-eclipse-workspace ()
  ;;   (if (null (search "workspace" (buffer-file-name)))
  ;;       ()
  ;;     (eclim-java-start)))


#+end_src
** lisp hook
#+begin_src emacs-lisp :tangle yes
  (defun lisp-modes-hook ()
    (eldoc-mode 1))

  (dolist (l-mode '(emacs-lisp-mode-hook
                    lisp-mode-hook))
    (add-hook l-mode 'lisp-modes-hook))

#+end_src
** perl hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'perl-mode-hook
            (lambda ()
              ;; (define-key perl-mode-map (kbd "<C-S-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-up t)))

              ;; (define-key perl-mode-map (kbd "<C-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-down t)))

              ;; (electric-pair-mode 1)
              ))
#+end_src
* Hydra
** various hydras
#+begin_src emacs-lisp :tangle yes
  ;; font zoom
  (defhydra hydra-zoom ()
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("q" nil "quit" :color blue))
  (define-key eriks-map (kbd "z") 'hydra-zoom/body)

  (defhydra hydra-windows (:hint nil :color blue)
    "
   ^Resize^         ^Transpose^        ^Move^            ^^^^   ^Split^
  -----------------------------------------------------------------------------------
    ^Horizontal^        ^_w_^             ^_k_^                 [_3_] : horizontal
   [_o_] : shrink     _a_   _d_         _h_   _l_               [_2_] : vertical
   [_p_] : enlarge      ^_s_^             ^_j_^                 [_0_] : close
    ^ ^                                               ^^^^^^^^  [_1_] : close other
    ^Vertical^         ^^          [_b_] : switch buffer  ^^^^  [_+_] : balance
   [_u_] : shrink      ^^          [_K_] : kill           ^^^^  [_4_] : kill and close
   [_i_] : enlarge     ^^          [_f_] : find file        ^ ^
   ^ ^                 ^^          [_x_] : run command
   Winner :: [_z_], [_Z_]
   _q_uit
  "
    ("h" windmove-left nil)
    ("l" windmove-right nil)
    ("k" windmove-up nil)
    ("j" windmove-down nil)
    ("o" shrink-window-horizontally nil :color red)
    ("p" enlarge-window-horizontally nil :color red)
    ("u" shrink-window nil :color red)
    ("i" enlarge-window nil :color red)
    ("w" buf-move-up nil)
    ("s" buf-move-down nil)
    ("a" buf-move-left nil)
    ("d" buf-move-right nil)
    ;; ("d" nil nil)
    ;; ("a" nil nil)
    ;; ("w" nil nil)
    ;; ("s" nil nil)
    ;; ("d" tabbar-forward-tab nil)
    ;; ("a" tabbar-backward-tab nil)
    ;; ("w" tabbar-forward-group nil)
    ;; ("s" tabbar-backward-group nil)
    ("b" ivy-switch-buffer nil)
    ("K" kill-this-buffer nil)
    ("3" split-window-horizontally nil)
    ("2" split-window-vertically nil)
    ("0" delete-window nil)
    ("1" delete-other-windows nil)
    ("+" balance-windows nil)
    ("4" kill-buffer-and-window nil)
    ("x" execute-extended-command nil)
    ("f" find-file nil)
    ("z" winner-undo nil)
    ("Z" winner-redo nil)
    ("q" nil nil :color blue))

  (define-key 'eriks-map (kbd "w") 'hydra-windows/body)
  ;; (define-key my-keys-map (kbd "C-w") 'hydra-windows/body)
#+end_src
** transpose
#+begin_src emacs-lisp :tangle yes
  ;; (defun eriks-transpose-char-forward ()
  ;;   (interactive)
  ;;   (forward-char)
  ;;   (transpose-chars 1)
  ;;   (forward-char -1))

  ;; (defun eriks-transpose-char-backward ()
  ;;   (interactive)
  ;;   (transpose-chars 1)
  ;;   (forward-char -2))

  ;; (defun eriks-transpose-word-forward ()
  ;;   (interactive)
  ;;   (transpose-words 1))

  ;; (defun eriks-transpose-word-backward ()
  ;;   (interactive)
  ;;   (transpose-words -1)
  ;;   (backward-word))

  ;; (defun eriks-transpose-paragraph-forward ()
  ;;   (interactive)
  ;;   (transpose-paragraphs 1))

  ;; (defun eriks-transpose-paragraph-backward ()
  ;;   (interactive)
  ;;   (transpose-paragraphs -1)
  ;;   (backward-paragraph))

  ;; (defun eriks-exchange-paragraphs ()
  ;;   (interactive)
  ;;   (transpose-paragraphs 0))

  ;; (defhydra hydra-transpose ()
  ;;   "Transpose: "
  ;;   ("k" move-line-up "line up")
  ;;   ("j" move-line-down "line down")
  ;;   ("h" eriks-transpose-char-backward "char backward")
  ;;   ("l" eriks-transpose-char-forward "char forward")
  ;;   ("f" eriks-transpose-word-forward "word forward")
  ;;   ("b" eriks-transpose-word-backward "word backward")
  ;;   ("n" eriks-transpose-paragraph-forward "paragraph forward")
  ;;   ("p" eriks-transpose-paragraph-backward "paragraph backward")
  ;;   ("e" eriks-exchange-paragraphs "paragraph exhange")
  ;;   ("r" eriks-region-switch "region switch" :color blue)
  ;;   ("R" eriks-region-switch-abort "region abort" :color blue)
  ;;   ("q" nil "quit" :color blue))


#+end_src
** org-table to hydra
*** macro definition
#+begin_src emacs-lisp :tangle yes
  (fset 'org-table-to-hydra-docstring
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([134217788 134217843 115 92 40 32 43 92 41 92 40 46 42 63 92 41 92 40 32 42 124 92 41 13 134217788 67108896 5 134217843 114 92 49 94 92 50 94 92 51 13 33 134217788 134217843 115 124 92 40 32 92 123 50 44 92 125 92 41 13 134217788 134217843 114 124 94 94 92 49 13 33 134217788 134217843 115 92 40 95 46 42 63 95 92 41 13 134217843 114 91 92 49 93 13 33 134217788 3 3 134217843 115 124 13 134217843 114 13 33 134217788 14 deletechar deletechar 94 94 134217843 115 45 92 43 45 13 134217843 114 94 94 13 33 134217788] 0 "%d")) arg)))

#+end_src

*** example
| head1      | head2      | head3            | head4      |
|------------+------------+------------------+------------|
| _h_ : grej | _g_ : sasd | _<right>_ : hej! | _a_ : asd! |
|            |            | _F_       : :)   |            |

==> formated as raw string

 ^head1^       ^head2^       ^head3^             ^head4^
^^-----------^^------------^^------------------^^-------------
 [_h_] : grej  [_g_] : sasd  [_<right>_] : hej!  [_a_] : asd!
 ^^            ^^            [_F_]       : :)    ^^

==> end result in hydra

 head1       head2       head3             head4
------------------------------------------------------
 [h] : grej  [g] : sasd  [<right>] : hej!  [a] : asd!
                         [F]       : :)
** rectangles
#+begin_src emacs-lisp :tangle yes
  (require 'picture)

  (defun pic-move (x y)
    "Uses picture-mode movement commands"
    ;;(interactive "P\nP")
    (cond
     ((> x 0) (picture-forward-column x))
     ((< x 0) (picture-backward-column (- x))))
    (cond
     ((> y 0) (picture-move-down y))
     ((< y 0) (picture-move-up (- y)))))

  ;; (defun mark-column ()
  ;;   (exchange-point-and-mark)
  ;;   (let ((col (current-column)))
  ;;     (exchange-point-and-mark)
  ;;     col))

  ;; (defun put-point-top-left-corner ()
  ;;   (line-number-at-pos (point))
  ;;   (let )
  ;;   (if (> (point) (mark))
  ;;       (exchange-point-and-mark)))

  ;; (defun move-rect (x y)
  ;;   (interactive "P\nP")
  ;;   (put-point-top-left-corner)
  ;;   (kill-rectangle)
  ;;   (pic-move x y)
  ;;   (let ((oldp (point)))
  ;;     )


  ;;   )

  ;; (move-rect 0 -1)


  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :hint nil
                                       :post (progn (deactivate-mark) (whitespace-cleanup)))
    "
    ^_k_^       _W_ copy      _o_pen       _N_umber-lines            |\\     -,,,--,,_
  _h_   _l_     _y_ank        _s_tring     _e_xchange-point          /,`.-'`'   ..  \-;;,_
    ^_j_^       _w_ kill      _c_lear      _m_ark                   |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _q_ quit     ^ ^                     '---''(./..)-'(_\_)
  "
    ("k" (pic-move 0 -1))
    ("j" (pic-move 0 1))
    ("h" (pic-move -1 0))
    ("l" (pic-move 1 0))
    ("w" kill-rectangle)                    ;; C-x r k
    ("y" yank-rectangle)                    ;; C-x r y
    ("W" copy-rectangle-as-kill)            ;; C-x r M-w
    ("o" open-rectangle)                    ;; C-x r o
    ("s" string-rectangle)                  ;; C-x r t
    ("c" clear-rectangle)                   ;; C-x r c
    ("e" exchange-point-and-mark)           ;; C-x C-x
    ("N" rectangle-number-lines)            ;; C-x r N
    ("m" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("u" undo nil)
    ("q" nil nil))
  (define-key my-keys-map (kbd "C-x SPC") 'hydra-rectangle/body)
#+end_src
** tags
#+begin_src emacs-lisp :tangle yes
  ;; (setq path-to-ctags "/usr/bin/ctags")

  ;; (defun create-tags (dir-name)
  ;;   "Create tags file."
  ;;   (interactive "DDirectory: ")
  ;;   (shell-command (format "%s -f TAGS -e -R \"%s\"" path-to-ctags (directory-file-name dir-name))))

  ;; (defhydra hydra-tags (:color blue :hint nil)
  ;;   "
  ;;  ^Setup^                    ^Find^
  ;; ^^^^----------------------------------------------------
  ;;  _c_reate                   _f_ind (-=back, u=continue)
  ;;  _v_isit-tags-table         _s_earch
  ;;  _r_egenerate (projectile)  _p_op
  ;;       ^^                    _l_oop-continue
  ;;  _q_uit                     _P_rojectile find
  ;; "
  ;;   ("c" create-tags nil :color red)
  ;;   ("v" visit-tags-table nil :color red)
  ;;   ("r" projectile-regenerate-tags nil :color red)
  ;;   ("f" find-tag nil)
  ;;   ("s" tags-search nil)
  ;;   ("p" pop-tag-mark nil)
  ;;   ("l" tags-loop-continue nil)
  ;;   ("P" projectile-find-tag nil)
  ;;   ("q" nil nil :color blue))

  ;; (defhydra hydra-gtags (:color blue :hint nil)
  ;;   "
  ;; ^Counsel^
  ;; ------------------------------------------
  ;; _d_ find definition    _n_ go forward
  ;; _r_ find reference     _f_ find dwim
  ;; _s_ find symbol        _u_ update gtags
  ;; _F_ find file          _c_ create gtags
  ;; _b_ go back
  ;; "
  ;;   ("d" counsel-gtags-find-definition nil)
  ;;   ("r" counsel-gtags-find-reference nil)
  ;;   ("s" counsel-gtags-find-reference nil)
  ;;   ("F" counsel-gtags-find-file nil)
  ;;   ("b" counsel-gtags-go-backward nil)
  ;;   ("n" counsel-gtags-go-forward nil)
  ;;   ("f" counsel-gtags-dwim)
  ;;   ("c" counsel-gtags-create-tags nil)
  ;;   ("u" counsel-gtags-update-tags)
  ;;   ("q" nil nil :color blue))

  (defhydra hydra-ggtags (:color blue :hint nil)
    "
               ggtags
  -^find^----------^tag files^----^other^-----------

   [_d_]efinition  [_u_]pdate     [_Q_]uery replace
   [_r_]eference   [_c_]create    [_p_]revious mark
   [_F_]ile        [_D_]elete     [_n_]ext mark
   dwi[_m_]                     ^^[_e_]xplain
   [_s_]ymbol
   [_R_]egexp                   ^^[_q_]uit
   [_S_]how definition
   [_g_]rep
  "
    ("d" ggtags-find-definition nil)
    ("S" ggtags-show-definition nil)
    ("R" ggtags-find-tag-regexp nil)
    ("Q" ggtags-query-replace nil)
    ("s" ggtags-find-other-symbol nil)
    ("r" ggtags-find-reference nil)
    ("F" ggtags-find-file nil)
    ("m" ggtags-find-tag-dwim nil)
    ("c" ggtags-create-tags nil :color red)
    ("u" ggtags-update-tags nil :color red)
    ("D" ggtags-delete-tags nil)
    ("e" ggtags-explain-tags nil)
    ("p" ggtags-prev-mark nil :color red)
    ("n" ggtags-next-mark nil :color red)
    ("g" ggtags-grep nil)
    ("q" nil nil :color blue))

  (define-key eriks-map (kbd "t") 'hydra-ggtags/body)

#+end_src
#+begin_src emacs-lisp :tangle yes
  (defhydra hydra-evil-numbers (:color red :hint nil)
    "
[_+_] increment  [_-_] decrement"
    ("+" evil-numbers/inc-at-pt nil)
    ("-" evil-numbers/dec-at-pt nil))
#+end_src
* hide minor mode lighters in modeline
#+begin_src emacs-lisp :tangle yes
  ;;shorten minor mode

  (add-hook 'autopair-mode-hook
            (lambda ()
              (diminish 'autopair-mode)))

  (diminish 'counsel-mode)
  (diminish 'which-key-mode)
  (diminish 'ivy-mode)
  (diminish 'undo-tree-mode)
  ;; (diminish 'auto-complete-mode)
  (diminish 'company-mode)
  (diminish 'yas-minor-mode)
  ;; (diminish 'disable-mouse-global-mode)
  (add-hook 'auto-revert-mode-hook
            (lambda ()
              (diminish 'auto-revert-mode)))

  ;;(diminish 'modalka-mode)
  ;;rm-text-properties, ta bort sakerna som smart-mode-line lägger till (face och sml/global(?)).
  ;; (diminish 'modalka-mode (format " %s" (propertize (all-the-icons-fileicon "emacs")
  ;;                                                   'face `(:family ,(all-the-icons-fileicon-family) :height 0.8 :foreground "cyan")
  ;;                                                   'display '(raise -0.1)
  ;;                                                   )))

  (diminish 'my-keys-minor-mode " mk")

  ;; (diminish 'my-keys-minor-mode (format " %s" (propertize (all-the-icons-faicon "keyboard-o")
  ;;                                                         'face `(:family ,(all-the-icons-faicon-family) :height 0.9)
  ;;                                                         'display '(raise 0.0)
  ;;                                                         )))

  (diminish 'outline-minor-mode (propertize " O" 'face '(:foreground "green")))

  (diminish 'smartparens-mode)

  (diminish 'projectile-mode)
  ;;(diminish 'all-the-icons-dired-mode)

  ;; (add-hook 'smartparens-mode-hook
  ;;           (lambda ()
  ;;             (diminish 'smartparens-mode)))

  ;;doesnt run :(
  (add-hook 'abbrev-mode-hook
            (lambda ()
              (diminish 'abbrev-mode)))
#+end_src

* random from internet
** insert a-z
#+begin_src emacs-lisp :tangle yes
  (defun insert-alphabet-az (&optional @use-uppercase-p)
    "Insert letters a to z vertically.
  If `universal-argument' is called first, use CAPITAL letters.

  URL `http://ergoemacs.org/emacs/emacs_insert-alphabets.html'
  Version 2015-11-06"
    (interactive "P")
    (let (($startChar (if @use-uppercase-p 65 97 )))
      (dotimes ($i 26)
        (insert (format "%c\n" (+ $startChar $i))))))
#+end_src
* nice kommandon
- M-^   -> delete-indentation (join-line)
- M-SPC -> just-one-space
- C-M-W -> append-next-kill
