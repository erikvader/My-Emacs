#+STARTUP: overview
#+STARTUP: indent
* Eriks keys minor mode
[[https://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs/5340797][Source from stackoverflow]]
#+begin_src emacs-lisp :tangle yes
  ;;(defvar my-keys-minor-mode-map
  ;;  (let ((map (make-sparse-keymap)))
      
  ;;    map)
  ;;  "my-keys-minor-mode keymap.")

  (setq my-keys-map (make-sparse-keymap))

  (define-minor-mode my-keys-minor-mode
    "my keymode to activate my keybindings"
    :global t
    :init-value t
    :lighter " my-keys"
    :keymap my-keys-map)

  ;; (define-globalized-minor-mode my-keys-global-mode
  ;;   my-keys-minor-mode
  ;;   (lambda ()
  ;;     (my-keys-minor-mode 1)))

  (my-keys-minor-mode 1)
  ;;(my-keys-global-mode 1)

  (global-set-key (kbd "<f1>") 'my-keys-minor-mode)

  ;;-----turn off i minibuffer------
  ;;(defun my-minibuffer-setup-hook ()
  ;;  (my-keys-minor-mode 0))

  ;;(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

  ;;-----reloada om en minor mode kommer in-----
  (add-hook 'after-load-functions 'my-keys-have-priority)

  (defun my-keys-have-priority (_file)
    "Try to ensure that my keybindings retain priority over other minor modes. Called via the `after-load-functions' special hook."
    (unless (eq (caar minor-mode-map-alist) 'my-keys-minor-mode)
      (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
        (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
        (add-to-list 'minor-mode-map-alist mykeys))))
#+end_src
** locally override
If you want to "always use the keybinds in the map, unless I explicitly 
override them for a specific mode-map", and assuming you are using 
scottfrazier's approach, you want:

So
#+begin_src emacs-lisp :tangle yes
(defun locally-override (key cmd)
    (unless (local-variable-p 'my-keys-minor-mode-map)
      (set (make-variable-buffer-local 'my-keys-minor-mode-map)
           (make-sparse-keymap))
      (set-keymap-parent my-keys-minor-mode-map 
                         (default-value 'my-keys-minor-mode-map)))
    (define-key my-keys-minor-mode-map key cmd))
#+end_src
(locally-override "\C-i" nil)

should remove the "\C-i" binding from the minor mode in the current buffer only. 
Warning: this is completely untested, but seems like the right approach. 
The point of setting the parent rather than just coping the global value of 
my-keys-minor-mode-map is so any later changes to the global value are automatically 
reflected in the local value.
* misc
#+begin_src emacs-lisp :tangle yes
  (browse-kill-ring-default-keybindings)
  (powerline-default-theme)
  (fset 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  (which-key-mode 1)
  ;;(setq org-ellipsis "⬎")
  ;;(smart-mode-line-enable)
  (setq inhibit-startup-screen t)
  ;; (setq auto-save-file-name-transforms
  ;;       (let (dir (expand-file-name "~/.emacs_auto_saves"))
  ;;         `((".*" dir t))))
                                          ; auto save path
  (defvar autosave-dir (concat "~/.emacs_auto_saves" "/"))
  (make-directory autosave-dir t)
  (setq auto-save-file-name-transforms
        `(("\\(?:[^/]*/\\)*\\(.*\\)" ,(concat autosave-dir "\\1") t)))

  ;; (add-hook 'dired-mode-hook
  ;;           (lambda ()
  ;;             (define-key dired-mode-map (kbd "å") 'dired-up-directory)
  ;;             ))

  (winner-mode 1)

  (global-disable-mouse-mode)

  (define-key my-keys-map (kbd "C-=") 'er/expand-region)
  (global-set-key (kbd "M-s r") 'isearch-query-replace-regexp)
  (global-set-key (kbd "M-s s") 'isearch-forward-regexp)
  (global-set-key (kbd "M-s S") 'isearch-backward-regexp)

#+end_src
* Eriks map / prefix key
** random
#+begin_src emacs-lisp :tangle yes
  (define-prefix-command 'eriks-map)
  ;;(global-set-key (kbd "C-ö") 'eriks-map)
  (define-key my-keys-map (kbd "C-r") 'eriks-map)

  (defun eriks-kill-line ()
    "Kills (cuts) the whole current line"
    (interactive)
    (setq col (current-column))
    (beginning-of-line)
    (delete-horizontal-space)
    (set-mark-command nil)
    (end-of-line)
    (if (not (eq (point) (mark)))
        (kill-region (point) (mark)))
    (deactivate-mark)
    ;;(kill-line 1)
    (delete-forward-char 1)
    (move-to-column col))

  (define-key eriks-map (kbd "d") 'eriks-kill-line)

  (defun eriks-add-semicolon ()
    "Goes to the end of the current line and adds an semicolon."
    (interactive)
    (move-end-of-line nil)
    (insert ";"))

  (defun eriks-add-semicolon-and-newline ()
    "what the name says"
    (interactive)
    (eriks-add-semicolon)
    (newline-without-break-down))


  (define-key eriks-map (kbd ":") 'eriks-add-semicolon)
  (define-key eriks-map (kbd ";") 'eriks-add-semicolon-and-newline)

  (defun eriks-insert-paren (p)
    (interactive "p")
    (end-of-line)
    (insert p)
    (left-char)
    (newline)
    (newline)
    (indent-for-tab-command)
    (forward-line -1)
    (indent-for-tab-command)
    )

  (define-key eriks-map (kbd "{") ;;TODO flytta till c-map
    (lambda ()
      (interactive)
      (eriks-insert-paren "{}")))

  (define-key eriks-map (kbd "t") 'ansi-term)

  (define-key eriks-map (kbd "c") 'whitespace-cleanup)

  (define-key eriks-map (kbd "i")
      (lambda ()
        (interactive)
        (find-file (expand-file-name "~/.emacs.d/myinit.org"))))

  (define-key eriks-map (kbd "g") 'magit-status)
#+end_src
** M-f, M-b, M-n, M-p
#+begin_src emacs-lisp :tangle yes
  (defun lxor (a b)
    "logical xor"
    (and
     (not (and a b))
     (or a b)))

  (defun lxnor (a b)
    "logical xnor"
    (not (lxor a b)))

  (defun is-boundary (char)
    (or
     (= char 32) ;;space
     (= char 10) ;;newline
     (= char 9)  ;; tab
     ;;(bolp)
     ;;(eolp)
     ))

  (defun erik-backward-word ()
    "Move between space separated tokens backwards"
    (interactive)
    (let ((w (is-boundary (preceding-char))))
      (while (lxnor w (is-boundary (preceding-char)))
        (backward-char))
      )
    )

  (defun erik-forward-word ()
    "Move between space separated tokens forwards"
    (interactive)
    (let ((w (is-boundary (following-char))))
      (while (lxnor w (is-boundary (following-char)))
        (forward-char))
      )
    )

  (define-key my-keys-map (kbd "M-f") 'erik-forward-word)
  (define-key my-keys-map (kbd "M-b") 'erik-backward-word)

  ;; experimental versions. skips quotes
  ;; (defun erik-backward-word ()
  ;;   "Move between space separated tokens backwards. Jumps over strings (weird behaviour if started inside a string)"
  ;;   (interactive)
  ;;   (let ((w (is-boundary (preceding-char)))
  ;;         (inQuotes nil)
  ;;         (prevQuote nil))
  ;;     (while (or
  ;;             inQuotes
  ;;             (lxnor w (is-boundary (preceding-char))))
  ;;       (if (and prevQuote (= 92 (preceding-char))) ;; \
  ;;           (setq inQuotes (not inQuotes)))
  ;;       (if (= 34 (preceding-char)) ;;" double quotes
  ;;           (progn
  ;;             (setq inQuotes (not inQuotes))
  ;;             (setq prevQuote t))
  ;;         (setq prevQuote nil))
  ;;       (backward-char))
  ;;     )
  ;;   (if (bobp)
  ;;       (message "Maybe unbalanced '\"', started inside string or just end of buffer"))
  ;;   )

  ;; (defun erik-forward-word ()
  ;;   "Move between space separated tokens forwards. Jumps over strings (weird behaviour if started inside a string)"
  ;;   (interactive)
  ;;   (let ((w (is-boundary (following-char)))
  ;;         (inQuotes nil)
  ;;         (esc nil))
  ;;     (while (or
  ;;             inQuotes
  ;;             (lxnor w (is-boundary (following-char))))
  ;;       (if (and (not esc) (= 34 (following-char))) ;;" double quotes
  ;;           (setq inQuotes (not inQuotes)))
  ;;       (if (= 92 (following-char)) ;; \
  ;;           (setq esc t)
  ;;         (setq esc nil))
  ;;       (forward-char))
  ;;     )
  ;;   (if (eobp)
  ;;       (message "Maybe unbalanced '\"', started inside string or just end of buffer"))
  ;;   )

  (define-key my-keys-map (kbd "M-p")
    (lambda ()
      (interactive)
      (previous-line 3)))

  (define-key my-keys-map (kbd "M-n")
    (lambda ()
      (interactive)
      (forward-line 3)))
#+end_src
* yasnippet
#+begin_src emacs-lisp :tangle yes
  ;;(require 'yasnippet)
  (yas-global-mode 1)
  ;;(require 'dropdown-list)
  ;;(setq yas-prompt-functions
  ;;      '(yas-dropdown-prompt
  ;;        yas-ido-prompt
  ;;        yas-x-prompt
  ;;        yas-completing-prompt
  ;;        yas-no-prompt))

  ;;removes expanding with tab. Uses 'Auto-complete' instead
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)

#+end_src
* Auto-complete
All default keybindings have been commented out in the source file 'auto-complete.el'

#+begin_src emacs-lisp :tangle yes
  (global-auto-complete-mode 1)
  (ac-config-default)

  (setq ac-dwim nil)

  (add-hook 'auto-complete-mode-hook
            (lambda ()
              ;;(define-key ac-completing-map (kbd "up") nil)
              ;;(define-key ac-completing-map (kbd "down") nil)
              ;;(define-key ac-completing-map (kbd "TAB") 'ac-next)
              (define-key ac-completing-map (kbd "<tab>") 'ac-expand)
              (define-key ac-completing-map (kbd "<backtab>") 'ac-expand-previous)
              (define-key ac-completing-map (kbd "C-o") 'ac-complete)
              ;;(define-key ac-menu-map (kbd "C-o") 'ac-complete)
              (define-key ac-completing-map (kbd "RET") 'ac-stop)
              (define-key ac-completing-map (kbd "C-n") 'ac-next)
              (define-key ac-completing-map (kbd "C-p") 'ac-previous)
              ))

  ;;adds yasnippet snippets to menu
  ;; (eval-after-load "auto-complete"
  ;;   '(add 'ac-sources 'ac-source-yasnippet))
  (eval-after-load "auto-complete"
    (lambda ()
      (add-to-list 'ac-sources 'ac-source-yasnippet)))

  ;;makes a key bring up the popup menu again if auto-complete is enabled
  ;;otherwise, try to expand with yas
  ;;(define-key ac-mode-map)
  (define-key my-keys-map (kbd "S-SPC")
        (lambda ()
          (interactive)
          (if (bound-and-true-p auto-complete-mode)
              (progn
                (ac-trigger-key-command 1)
                (message "auto-complete"))
            (progn
              (yas-expand)
              (message "yasnippet")))))


#+end_src
* undo-tree
#+begin_src emacs-lisp :tangle yes
  (global-undo-tree-mode 1)
  (global-set-key (kbd "C-z") 'undo)
  ;;(define-key my-keys-map (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'undo-tree-redo)
  ;;(define-key my-keys-map (kbd "C-S-z") 'undo-tree-redo)
  (define-key eriks-map (kbd "u") 'undo-tree-visualize)
#+end_src
* ivy and avy
#+begin_src emacs-lisp :tangle yes
  ;;ivy
  (ivy-mode 1)
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
  ;;(define-key ivy-minibuffer-map (kbd "<tab>") 'ivy-partial)

  ;;avy
  ;;(define-prefix-command 'eriks-avy-map)
  ;;(define-key my-keys-map (kbd "M-s") 'eriks-avy-map)
  ;;(global-set-key (kbd "M-s") 'avy-goto-char)
  (define-key eriks-map (kbd "r") 'avy-goto-char)
  (define-key eriks-map (kbd "C-r") 'avy-goto-char-2)

  ;;dired
  ;;(add-hook 'dired-mode-hook
  ;;          (lambda ()
  ;;            (define-key dired-mode-map (kbd "M-s s") 'avy-goto-char)))
  (setq ivy-use-selectable-prompt t)
#+end_src
* window manipulation
#+begin_src emacs-lisp :tangle yes
  ;; (define-key my-keys-map (kbd "S-C-<left>") 'shrink-window-horizontally)
  ;; (define-key my-keys-map (kbd "S-C-<right>") 'enlarge-window-horizontally)
  ;; (define-key my-keys-map (kbd "S-C-<down>") 'shrink-window)
  ;; (define-key my-keys-map (kbd "S-C-<up>") 'enlarge-window)

  ;; (define-key my-keys-map (kbd "C-<right>") 'tabbar-forward-tab)
  ;; (define-key my-keys-map (kbd "C-<left>") 'tabbar-backward-tab)
  ;; (define-key my-keys-map (kbd "C-<up>") 'tabbar-forward-group)
  ;; (define-key my-keys-map (kbd "C-<down>") 'tabbar-backward-group)

  ;; ;;(windmove-default-keybindings)

  (define-key my-keys-map (kbd "S-<right>") 'windmove-right)
  (define-key my-keys-map (kbd "S-<left>") 'windmove-left)
  (define-key my-keys-map (kbd "S-<up>") 'windmove-up)
  (define-key my-keys-map (kbd "S-<down>") 'windmove-down)
#+end_src
* o and O from VIM
#+begin_src emacs-lisp :tangle yes
  (setq newline-without-break-tab nil)

  (defun newline-without-break-down ()
    "Add new line below and go to it. tab if an argument is given"
    (interactive)
    (end-of-line)
    (newline)
    (if newline-without-break-tab (indent-for-tab-command)))

  (defun newline-without-break-up ()
    "Add new line above and go to it. tab if an argument is given"
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (if newline-without-break-tab (indent-for-tab-command)))

  ;;(define-key cua-global-keymap [C-return] nil) ;;ta bort C-return from cua
  (define-key my-keys-map (kbd "<C-return>") 'newline-without-break-down)
  (define-key my-keys-map (kbd "<C-S-return>") 'newline-without-break-up)

#+end_src
* prog-mode-hook
** prog-mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook
            (lambda ()
              (make-local-variable 'newline-without-break-tab)
              (setq newline-without-break-tab t)
              ;;(autopair-mode 1)
              ;;(paredit-mode t)
              (start-smartparens)
              (setq show-trailing-whitespace t)
              (rainbow-delimiters-mode t)))
#+end_src
** C-mode hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook
            (lambda ()
              (flycheck-mode 1)
              (run-hooks 'abbrev-mode-hook) ;;för att den inte verkar göra det själv
                            
              ;;(add-to-list 'ac-sources 'ac-source-c-headers)
              ;;(add-to-list 'ac-sources 'ac-source-c-header-symbols t)
              ;; (define-key c-mode-base-map (kbd "<C-S-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-up t)))
              
              ;; (define-key c-mode-base-map (kbd "<C-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-down t)))
              
              ;;(electric-pair-mode 1)
              ;;(make-local-variable 'newline-without-break-tab)
              ;;(setq newline-without-break-tab t)
              ;;(autopair-mode)
              ;;(setq show-trailing-whitespace t)
              ))
#+end_src
** lisp hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (smartparens-strict-mode t)
              ;;(make-local-variable 'newline-without-break-tab)
              ;;(setq newline-without-break-tab t)
              ;;(autopair-mode)
              ;;(setq show-trailing-whitespace t)
              ))

#+end_src
** perl hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'perl-mode-hook
            (lambda ()
              ;; (define-key perl-mode-map (kbd "<C-S-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-up t)))
              
              ;; (define-key perl-mode-map (kbd "<C-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-down t)))
              
              ;; (electric-pair-mode 1)
              ))
#+end_src
** java hook
*** eclim
#+begin_src emacs-lisp :tangle yes
  (require 'eclim)
  (setq eclimd-autostart nil)

  (custom-set-variables
   '(eclim-eclipse-dirs '("~/bin/eclipse-neon"))
   '(eclim-executable "~/bin/eclipse-neon/eclim"))

  ;;(setq help-at-pt-display-when-idle t)
  ;;(setq help-at-pt-timer-delay 0.1)
  ;;(help-at-pt-set-timer)

  (add-hook 'eclim-mode-hook
            (lambda ()
              (define-key eclim-mode-map (kbd "C-c C-e C-b") 'eclim-project-build)
              (define-key eclim-mode-map (kbd "C-c C-e d") nil)
              (define-key eclim-mode-map (kbd "C-c C-e d d") 'eclim-java-show-documentation-for-current-element)
              (define-key eclim-mode-map (kbd "C-c C-e d f") 'eclim-java-browse-documentation-at-point)
              (define-key eclim-mode-map (kbd "C-c C-e d s") 'eclim-java-doc-comment)
              ))

  (add-hook 'java-mode-hook
            (lambda ()
              (flycheck-mode -1)
              (start-eclim-if-inside-eclipse-workspace)))

  (defun eclim-java-start ()
    (interactive)
    (eclim-mode t)
    (require 'ac-emacs-eclim)
    ;;(ac-emacs-eclim-config)
    (ac-emacs-eclim-java-setup)
    )

  (defun start-eclim-if-inside-eclipse-workspace ()
    (if (null (search "workspace" (buffer-file-name)))
        ()
      (eclim-java-start)))


#+end_src
*** non-eclim
#+begin_src emacs-lisp :tangle yes

#+end_src
* move lines from internet
#+begin_src emacs-lisp :tangle yes
  ;; (defun move-line (n)
  ;;   "Move the current line up or down by N lines. Buggar for second last line i buffern"
  ;;   (interactive "p")
  ;;   (setq col (current-column))
  ;;   (beginning-of-line)
  ;;   (setq start (point))
  ;;   (end-of-line)
  ;;   (if (eobp)
  ;;       (newline)
  ;;     (forward-char))
  ;;   (setq end (point))
  ;;   (let ((line-text (delete-and-extract-region start end)))
  ;;     (forward-line n)
  ;;     (if (eobp) (newline))
  ;;     (insert line-text)
  ;;     ;; restore point to original column in moved line
  ;;     (forward-line -1)
  ;;     (move-to-column col)))

  ;; (defun move-line-up (n)
  ;;   "Move the current line up by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) -1 (- n))))

  ;; (defun move-line-down (n)
  ;;   "Move the current line down by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) 1 n)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (transpose-lines 1)
      (previous-line 2)
      (move-to-column col)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (next-line 1)
      (transpose-lines 1)
      (previous-line 1)
      (move-to-column col)))

  (define-key my-keys-map (kbd "M-<up>") 'move-line-up)
  (define-key my-keys-map (kbd "M-<down>") 'move-line-down)

#+end_src
* golden ratio scroll
#+begin_src emacs-lisp :tangle yes
  (global-set-key [remap scroll-down-command] 'golden-ratio-scroll-screen-down)
  (global-set-key [remap scroll-up-command] 'golden-ratio-scroll-screen-up)
#+end_src
* hide minor mode lighters in modeline
#+begin_src emacs-lisp :tangle yes
  ;;shorten minor mode

  (add-hook 'autopair-mode-hook
            (lambda ()
              (diminish 'autopair-mode)))

  (diminish 'which-key-mode)
  (diminish 'ivy-mode)
  (diminish 'undo-tree-mode)
  (diminish 'auto-complete-mode)
  (diminish 'yas-minor-mode)
  (diminish 'global-disable-mouse-mode)

  (add-hook 'smartparens-mode-hook
            (lambda ()
              (diminish 'smartparens-mode)))

  ;;doesnt run :(
  (add-hook 'abbrev-mode-hook
            (lambda ()
              (diminish 'abbrev-mode)))
#+end_src
* projectile
#+begin_src emacs-lisp :tangle yes
  (projectile-global-mode t)
  (counsel-projectile-on)
#+end_src
* dumb jump
#+begin_src emacs-lisp :tangle yes
  ;;(dumb-jump-mode)

  (define-key eriks-map (kbd "j j") 'dumb-jump-go)
  (define-key eriks-map (kbd "j b") 'dumb-jump-back)

  (setq dumb-jump-selector 'ivy)

#+end_src
* neotree
#+begin_src emacs-lisp :tangle yes
  ;;When running ‘projectile-switch-project’ (C-c p p), ‘neotree’ will change root automatically.
  ;;(setq projectile-switch-project-action 'neotree-projectile-action)

  ;;Every time when the neotree window is opened, let it find current file and jump to node.
  ;;(setq neo-smart-open t)

  ;;Similar to find-file-in-project, NeoTree can be opened (toggled) at projectile project root as follows:
  (defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))

  ;; (global-set-key [f8] 'neotree-toggle)
  ;; (global-set-key (kbd "S-<f8>") 'neotree-find)
  ;; (global-set-key [f9] 'neotree-project-dir)

  (defhydra hydra-neotree (:color blue)
    "neotree"
    ("<f8>" neotree-toggle "toggle")
    ("f" neotree-find "file dir")
    ("p" neotree-project-dir "project dir"))
  (define-key my-keys-map (kbd "<f8>") 'hydra-neotree/body)
#+end_src
* multiple cursors
#+begin_src emacs-lisp :tangle yes
  ;; (define-key 'eriks-map (kbd "m l") 'mc/edit-lines)
  ;; (define-key 'eriks-map (kbd "m m") 'mc/mark-next-like-this)
  ;; (define-key 'eriks-map (kbd "m n") 'mc/mark-previous-like-this)
  ;; (define-key 'eriks-map (kbd "m b") 'mc/mark-all-like-this)
#+end_src
* Hydra
** various hydras
#+begin_src emacs-lisp :tangle yes
  ;; font zoom
  (defhydra hydra-zoom ()
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("q" nil "quit" :color blue))
  (define-key eriks-map (kbd "z") 'hydra-zoom/body)

  (defhydra hydra-windows ()
    "
   ^Resize^               ^Move^               ^Transpose^    ^Buffer^                        ^Split^
  ------------------------------------------------------------------------------------------------------------
   [_d_] : shrink hori    [_<left>_]  : left   [_t_] : up     [_C-<right>_] : forward tab     [_3_] : horizontal
   [_a_] : enlarge hori   [_<right>_] : right  [_g_] : down   [_C-<left>_]  : backward tab    [_2_] : vertical
   [_s_] : shrink verti   [_<up>_]    : up     [_f_] : left   [_C-<up>_]    : forward group   [_0_] : close
   [_w_] : enlarge verti  [_<down>_]  : down   [_h_] : right  [_C-<down>_]  : backward group  [_1_] : close other
   ^ ^                     ^      ^             ^ ^           [_b_]         : switch buffer   [_+_] : balance
   ^ ^                     ^      ^             ^ ^           [_k_]         : kill            [_4_] : kill and close
   ^ ^                     ^      ^             ^ ^           [_f_]         : find file        ^ ^
   ^ ^                     ^      ^             ^ ^           [_x_]         : run command
  "
    ("<left>" windmove-left nil)
    ("<right>" windmove-right nil)
    ("<up>" windmove-up nil)
    ("<down>" windmove-down nil)
    ("d" shrink-window-horizontally nil)
    ("a" enlarge-window-horizontally nil)
    ("s" shrink-window nil)
    ("w" enlarge-window nil)
    ("t" buf-move-up nil)
    ("g" buf-move-down nil)
    ("f" buf-move-left nil)
    ("h" buf-move-right nil)
    ("C-<right>" tabbar-forward-tab nil)
    ("C-<left>" tabbar-backward-tab nil)
    ("C-<up>" tabbar-forward-group nil)
    ("C-<down>" tabbar-backward-group nil)
    ("b" ivy-switch-buffer nil)
    ("k" kill-this-buffer nil)
    ("3" split-window-horizontally nil)
    ("2" split-window-vertically nil)
    ("0" delete-window nil)
    ("1" delete-other-windows nil)
    ("+" balance-windows nil)
    ("4" kill-buffer-and-window nil)
    ("x" execute-extended-command nil)
    ("f" find-file nil)
    ("q" nil "quit ":color blue))
  (define-key 'eriks-map (kbd "w") 'hydra-windows/body)


  (defhydra hydra-multiple-cursors ()
    "
       ^Up^            ^Down^        ^Other^
  ----------------------------------------------
  [_p_]   Next    [_n_]   Next    [_l_] Edit lines
  [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
  [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
  ^ ^             ^ ^             [_q_] Quit
  "
    ("l" mc/edit-lines nil :exit t)
    ("a" mc/mark-all-like-this nil :exit t)
    ("n" mc/mark-next-like-this nil)
    ("N" mc/skip-to-next-like-this nil)
    ("M-n" mc/unmark-next-like-this nil)
    ("p" mc/mark-previous-like-this nil)
    ("P" mc/skip-to-previous-like-this nil)
    ("M-p" mc/unmark-previous-like-this nil)
    ("r" mc/mark-all-in-region-regexp nil :exit t)
    ("q" nil nil))
  (define-key 'eriks-map (kbd "m") 'hydra-multiple-cursors/body)
#+end_src
** org-table to hydra
*** macro definition
#+begin_src emacs-lisp :tangle yes
  (fset 'org-table-to-hydra-docstring
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([134217788 134217843 115 92 40 32 43 92 41 92 40 46 42 63 92 41 92 40 32 42 124 92 41 13 134217788 67108896 5 134217843 114 92 49 94 92 50 94 92 51 13 33 134217788 134217843 115 124 92 40 32 92 123 50 44 92 125 92 41 13 134217788 134217843 114 124 94 94 92 49 13 33 134217788 134217843 115 92 40 95 46 42 63 95 92 41 13 134217843 114 91 92 49 93 13 33 134217788 3 3 134217843 115 124 13 134217843 114 13 33 134217788 14 deletechar deletechar 94 94 134217843 115 45 92 43 45 13 134217843 114 94 94 13 33 134217788] 0 "%d")) arg)))

#+end_src

*** example
| head1      | head2      | head3            | head4      |
|------------+------------+------------------+------------|
| _h_ : grej | _g_ : sasd | _<right>_ : hej! | _a_ : asd! |
|            |            | _F_       : :)   |            |

==> formated as raw string

 ^head1^       ^head2^       ^head3^             ^head4^      
^^-----------^^------------^^------------------^^-------------
 [_h_] : grej  [_g_] : sasd  [_<right>_] : hej!  [_a_] : asd! 
 ^^            ^^            [_F_]       : :)    ^^           

==> end result in hydra

 head1       head2       head3             head4      
------------------------------------------------------
 [h] : grej  [g] : sasd  [<right>] : hej!  [a] : asd! 
                         [F]       : :)               
                         
* paredit
#+begin_src emacs-lisp :tangle yes
  ;; (define-key paredit-mode-map (kbd "C-S-<left>") 'paredit-backward-slurp-sexp)
  ;; (define-key paredit-mode-map (kbd "C-S-<right>") 'paredit-backward-barf-sexp)
#+end_src
* smartparens
** standard config
#+begin_src emacs-lisp :tangle yes
  (require 'smartparens-config)

  (defun start-smartparens ()
    (smartparens-mode t)

    (define-key smartparens-mode-map (kbd "C-M-SPC") 'sp-mark-sexp)

    (define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
    (define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

    (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)

    (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
    (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)

    (define-key eriks-map (kbd "p") 'start-hydra-smartparens-if-activated)
    )

  (defun start-hydra-smartparens-if-activated ()
    (interactive)
    (if (bound-and-true-p smartparens-mode)
        (hydra-smartparens/body)
      (message "smartparens not activated!")))

  (defhydra hydra-smartparens (:color pink)
    "
   ^forward^      ^backward^     ^Sexp^          ^Hybrid^
  ^^^^^^^^-----------------------------------------------------
   [_k_] : barf   [_i_] : slurp  [_K_] : kill    [_a_] : kill
   [_l_] : slurp  [_o_] : barf   [_s_] : splice  [_w_] : slurp
    ^ ^            ^ ^           [_S_] : split   [_e_] : barf
    ^ ^            ^ ^           [_J_] : join     ^ ^
  "
    ("K" sp-kill-sexp nil)
    ("s" sp-splice-sexp nil)
    ("S" sp-split-sexp nil)
    ("J" sp-join-sexp nil)
    ("k" sp-forward-barf-sexp nil)
    ("l" sp-forward-slurp-sexp nil)
    ("i" sp-backward-slurp-sexp nil)
    ("o" sp-backward-barf-sexp nil)
    ("a" sp-kill-hybrid-sexp nil)
    ("w" sp-slurp-hybrid-sexp nil)
    ("e" sp-dedent-adjust-sexp nil)
    ("q" nil "Quit" :color blue))

#+end_src
** parenthesis
#+begin_src emacs-lisp :tangle yes
  (defun my-create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))


  (sp-local-pair '(c-mode java-mode) "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
  ;;(sp-local-pair 'java-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))

#+end_src
