#+STARTUP: overview
#+STARTUP: indent
* require
#+begin_src emacs-lisp :tangle yes
  (require 'cc-mode)
  (require 'seq)

#+end_src
* Eriks keys minor mode
[[https://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs/5340797][Source from stackoverflow]]
#+begin_src emacs-lisp :tangle yes
  ;;(defvar my-keys-minor-mode-map
  ;;  (let ((map (make-sparse-keymap)))

  ;;    map)
  ;;  "my-keys-minor-mode keymap.")

  (setq my-keys-map (make-sparse-keymap)) ;;varför gör jag såhär?

  (define-minor-mode my-keys-minor-mode
    "my keymode to activate my keybindings"
    :global t
    :init-value t
    :lighter " my-keys"
    :keymap my-keys-map)

  ;; (define-globalized-minor-mode my-keys-global-mode
  ;;   my-keys-minor-mode
  ;;   (lambda ()
  ;;     (my-keys-minor-mode 1)))

  (my-keys-minor-mode 1)
  ;;(my-keys-global-mode 1)

  (global-set-key (kbd "<f1>") 'my-keys-minor-mode)

  ;;-----turn off i minibuffer------
  ;;(defun my-minibuffer-setup-hook ()
  ;;  (my-keys-minor-mode 0))

  ;;(add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

  ;;-----reloada om en minor mode kommer in-----
  (add-hook 'after-load-functions 'my-keys-have-priority)

  (defun my-keys-have-priority (_file)
    "Try to ensure that my keybindings retain priority over other minor modes. Called via the `after-load-functions' special hook."
    (unless (eq (caar minor-mode-map-alist) 'my-keys-minor-mode)
      (let ((mykeys (assq 'my-keys-minor-mode minor-mode-map-alist)))
        (assq-delete-all 'my-keys-minor-mode minor-mode-map-alist)
        (add-to-list 'minor-mode-map-alist mykeys))))
#+end_src
** locally override
If you want to "always use the keybinds in the map, unless I explicitly
override them for a specific mode-map", and assuming you are using
scottfrazier's approach, you want:

So
#+begin_src emacs-lisp :tangle yes
(defun locally-override (key cmd)
    (unless (local-variable-p 'my-keys-minor-mode-map)
      (set (make-variable-buffer-local 'my-keys-minor-mode-map)
           (make-sparse-keymap))
      (set-keymap-parent my-keys-minor-mode-map
                         (default-value 'my-keys-minor-mode-map)))
    (define-key my-keys-minor-mode-map key cmd))
#+end_src
(locally-override "\C-i" nil)

should remove the "\C-i" binding from the minor mode in the current buffer only.
Warning: this is completely untested, but seems like the right approach.
The point of setting the parent rather than just coping the global value of
my-keys-minor-mode-map is so any later changes to the global value are automatically
reflected in the local value.
* misc
#+begin_src emacs-lisp :tangle yes
  (browse-kill-ring-default-keybindings)
  ;; (powerline-default-theme)

  (require 'all-the-icons)
  ;; (require 'all-the-icons-ivy)
  ;; (all-the-icons-ivy-setup)
  (all-the-icons-dired-mode)

  (require 'smart-mode-line)
  (sml/setup)

  (fset 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "<f5>") 'revert-buffer)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
  (which-key-mode 1)
  ;;(setq org-ellipsis "⬎")
  ;;(smart-mode-line-enable)
  (setq inhibit-startup-screen t)
  ;; (setq auto-save-file-name-transforms
  ;;       (let (dir (expand-file-name "~/.emacs_auto_saves"))
  ;;         `((".*" dir t))))
                                          ; auto save path
  (defvar autosave-dir (concat "~/.emacs_auto_saves" "/"))
  (make-directory autosave-dir t)
  (setq auto-save-file-name-transforms
        `(("\\(?:[^/]*/\\)*\\(.*\\)" ,(concat autosave-dir "\\1") t)))

  (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)

  (winner-mode 1)

  ;;(global-disable-mouse-mode)

  (define-key my-keys-map (kbd "C-+") 'er/expand-region)
  (global-set-key (kbd "M-s r") 'isearch-query-replace-regexp)
  (global-set-key (kbd "M-s s") 'isearch-forward-regexp)
  (global-set-key (kbd "M-s S") 'isearch-backward-regexp)

  ;;magit fixar detta redan med ett egen global mode
  ;;(global-auto-revert-mode t)

  (define-key input-decode-map [?\C-i] [C-i])
  ;;(global-set-key (kbd "<C-i>") 'indent-region)
  (define-key input-decode-map [?\C-m] [C-m])
  ;;(global-set-key (kbd "<C-i>") 'indent-region)

  (defun replace-char (c)
    "Replaces current char with a prompted one"
    (interactive "cReplacement: ")
    (delete-char 1)
    (insert-char c)
    (backward-char)
    )

  (define-key my-keys-map (kbd "C-r") 'replace-char)

  ;;support för font awesome
  ;; (set-fontset-font "fontset-default" '(#xf000 . #xffff) "Font Awesome")

  (defun backward-symbol (&optional arg)
   "Move backward until encountering the beginning of a symbol.
  With argument, do this that many times."
   (interactive "p")
   (forward-symbol (- (or arg 1))))

  (define-key my-keys-map (kbd "<f3>") 'kmacro-start-macro)

  (define-key my-keys-map (kbd "S-<right>") 'windmove-right)
  (define-key my-keys-map (kbd "S-<left>") 'windmove-left)
  (define-key my-keys-map (kbd "S-<up>") 'windmove-up)
  (define-key my-keys-map (kbd "S-<down>") 'windmove-down)

  (defun eriks-pop-kill-ring ()
    (interactive)
    (setq kill-ring (cdr kill-ring))
    (setq kill-ring-yank-pointer kill-ring))

  (setq line-move-visual nil)

  ;;to fix bug with expand-region (issue 220 on github)
  (setq shift-select-mode nil)
#+end_src
* Eriks map / prefix key
** random
#+begin_src emacs-lisp :tangle yes
  (define-prefix-command 'eriks-map)
  ;;(global-set-key (kbd "C-ö") 'eriks-map)
  (define-key my-keys-map (kbd "C-SPC") 'eriks-map)
  (define-key my-keys-map (kbd "<C-m>") 'set-mark-command)

  (define-key eriks-map (kbd "f r") 'fill-region)
  (define-key eriks-map (kbd "f p") 'fill-region-as-paragraph)
  (define-key eriks-map (kbd "f f") 'fill-paragraph)

  (define-key eriks-map (kbd "C-f") 'ff-find-other-file)

  (define-key eriks-map (kbd "r") 'linum-relative-toggle)
  (linum-relative-toggle)

  (define-key eriks-map (kbd "l") 'eriks-toggle-visual-line)

  (defun eriks-toggle-visual-line ()
    (interactive)
    (setq line-move-visual (not line-move-visual)))

  (defun eriks-kill-line ()
    "Kills (cuts) the whole current line"
    (interactive)
    (setq col (current-column))
    (beginning-of-line)
    (delete-horizontal-space)
    (set-mark-command nil)
    (end-of-line)
    (if (not (eq (point) (mark)))
        (kill-region (point) (mark)))
    (deactivate-mark)
    ;;(kill-line 1)
    (delete-forward-char 1)
    (move-to-column col))

  (define-key eriks-map (kbd "d") 'eriks-kill-line)

  (defun eriks-add-semicolon ()
    "Goes to the end of the current line and adds an semicolon."
    (interactive)
    (move-end-of-line nil)
    (insert ";"))

  (defun eriks-add-semicolon-and-newline ()
    "what the name says"
    (interactive)
    (eriks-add-semicolon)
    (newline-without-break-down))


  (define-key eriks-map (kbd ":") 'eriks-add-semicolon)
  (define-key eriks-map (kbd ";") 'eriks-add-semicolon-and-newline)

  (defun eriks-insert-paren (p)
    (interactive "p")
    (end-of-line)
    (insert p)
    (left-char)
    (newline)
    (newline)
    (indent-for-tab-command)
    (forward-line -1)
    (indent-for-tab-command)
    )

  ;; (define-key eriks-map (kbd "{") ;;TODO flytta till c-map
  ;;   (lambda ()
  ;;     (interactive)
  ;;     (eriks-insert-paren "{}")))

  (define-key eriks-map (kbd "y") 'ansi-term)

  (define-key eriks-map (kbd "c") 'whitespace-cleanup)

  ;; (defun edit-myinit-org ()
  ;;   (interactive)
  ;;   (find-file (expand-file-name "~/.emacs.d/myinit.org")))

  ;;(define-key eriks-map (kbd "i") 'edit-myinit-org)

  (define-key eriks-map (kbd "g") 'magit-status)
  (define-key eriks-map (kbd "U") 'counsel-unicode-char)
  ;;(define-key eriks-map (kbd "M") 'counsel-mark-ring)

  (defun sign (a)
    "The sign of a typ
  a >= 0 ->  1
  a <  0 -> -1"
    (if (>= a 0)
        1
      -1))

  (defun abs (a)
    "abs av a"
    (if (< a 0)
        (- 0 a)
      a))
#+end_src
** lxor & is-boundary
#+begin_src emacs-lisp :tangle yes
  (defun lxor (a b)
    "logical xor"
    (and
     (not (and a b))
     (or a b)))

  (defun lxnor (a b)
    "logical xnor"
    (not (lxor a b)))

  (defun is-boundary (char)
    "Checks whether char is a space, newline or tab"
    (or
     (= char 32) ;;space
     (= char 10) ;;newline
     (= char 9)  ;; tab
     ;;(bolp)
     ;;(eolp)
     ))
#+end_src
** erik-funktioner
#+begin_src emacs-lisp :tangle yes
  ;; (defun eriks-kill-stuff (dir symbol arg)
  ;;   (if (equal arg '(4))
  ;;       (eriks-hungry-delete-whitespace dir)
  ;;     (let ((p (* dir (prefix-numeric-value arg))))
  ;;       (if symbol
  ;;           (sp-kill-symbol p)
  ;;         (sp-kill-word p)))))

  ;; (defun eriks-kill-backward (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff -1 nil ARG))

  ;; (defun eriks-kill-forward (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff 1 nil ARG))

  ;; (defun eriks-kill-forward-symbol (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff 1 t ARG))

  ;; (defun eriks-kill-backward-symbol (ARG)
  ;;   (interactive "P")
  ;;   (eriks-kill-stuff -1 t ARG))

  (defun eriks-hungry-delete-whitespace (ARG)
    (interactive "p")
    (if (< ARG 0)
        (while (is-boundary (preceding-char))
          (delete-backward-char 1))
      (while (is-boundary (following-char))
        (delete-char 1))))

  (defun eriks-hungry-delete-whitespace-backward (ARG)
    (interactive "p")
    (eriks-hungry-delete-whitespace (- 0 ARG)))

  ;; (define-key my-keys-map (kbd "C-<backspace>") 'eriks-delete-backward)
  ;; (define-key my-keys-map (kbd "C-<delete>") 'eriks-delete-forward)

  (defun eriks-duplicate-line ()
    (interactive)
    (let* ((b (progn
                (beginning-of-line)
                (point)))
           (e (progn
                (end-of-line)
                (point)))
           (line (buffer-substring b e)))
      (end-of-line)
      (newline)
      (insert line)))

  ;;TODO make ARG execute the command ARG times
  (defun eriks-find-char (ARG c)
    "Like vim's f-command.

  With no prefix argument or as 1, move cursor forward until the first occurence of c.
  With ARG as -1 (M--), move backward until the first occurence of c.
  If c can't be found, do nothing and print a nice message.

  Ignores case!

  returns t if successful, nil otherwise"
    (interactive "p\ncJump to char: ")
    (let ((dir (sign ARG))
          (start (point))
          (finished nil))
      (while (and
              (not (or
                    (and (> dir 0) (eobp))
                    (and (< dir 0) (bobp))))
              (not finished))
        (forward-char dir)
        (if (= (downcase c) (downcase (following-char)))
            (setq finished t)))
      (if (not finished)
          (progn
            (goto-char start)
            (message "Couldn't find '%c' :(" c)
            nil)
        t)))

  (defun eriks-find-char-backward (ARG c)
    "Exactly the same behaviour as `eriks-find-char' except this goes backwards by negating ARG"
    (interactive "p\ncJump to char backwards: ")
    (eriks-find-char (- 0 ARG) c))

  (defun eriks-find-char-alt ()
    (interactive)
    (if (call-interactively 'eriks-find-char)
        (forward-char)))

  (defun eriks-find-char-alt-backward ()
    (interactive)
    (if (call-interactively 'eriks-find-char-backward)
        (forward-char)))

  (defun eriks-skip-space (ARG)
    "Move point forward or backward until it doesnt encounter whitespace anymore."
    (interactive "p")
    (if (< ARG 0)
        (while (is-boundary (preceding-char))
          (left-char))
      (while (is-boundary (following-char))
        (right-char))))

  (defun eriks-skip-space-backwards ()
    (interactive)
    (eriks-skip-space -1))

  (defun eriks-beginning-of-line (ARG)
    "Just as `beginning-of-line' except if prefixed with C-u it skips over whitespace at the beginning of the line."
    (interactive "P")
    (beginning-of-line)
    (if (equal ARG '(4))
        (eriks-skip-space 1)))

  (define-key my-keys-map (kbd "C-a") 'eriks-beginning-of-line)

  (defun eriks-kill-paragraph ()
    "Kills the current paragraph point is in."
    (interactive)
    (eriks-kill-thing-at-point 'paragraph))

  (defun eriks-backward-kill-line ()
    (interactive)
    (kill-line 0))

  (defun eriks-mark-line ()
    (interactive)
    (beginning-of-line)
    (push-mark (point) nil t)
    (end-of-line))

  (defun eriks-insert-char (ARG c)
    (interactive "p\ncInsert: ")
    (dotimes (i ARG)
      (insert c)))
#+end_src
** o and O from VIM
#+begin_src emacs-lisp :tangle yes
  (setq newline-without-break-tab nil)

  (defun newline-without-break-down ()
    "Add new line below and go to it. tab if an argument is given"
    (interactive)
    (end-of-line)
    (newline)
    (if newline-without-break-tab (indent-for-tab-command)))

  (defun newline-without-break-up ()
    "Add new line above and go to it. tab if an argument is given"
    (interactive)
    (beginning-of-line)
    (newline)
    (forward-line -1)
    (if newline-without-break-tab (indent-for-tab-command)))

  ;;(define-key cua-global-keymap [C-return] nil) ;;ta bort C-return from cua
  (define-key my-keys-map (kbd "<C-return>") 'newline-without-break-down)
  (define-key my-keys-map (kbd "<C-S-return>") 'newline-without-break-up)

#+end_src
** move lines from internet

#+begin_src emacs-lisp :tangle yes
  ;; (defun move-line (n)
  ;;   "Move the current line up or down by N lines. Buggar for second last line i buffern"
  ;;   (interactive "p")
  ;;   (setq col (current-column))
  ;;   (beginning-of-line)
  ;;   (setq start (point))
  ;;   (end-of-line)
  ;;   (if (eobp)
  ;;       (newline)
  ;;     (forward-char))
  ;;   (setq end (point))
  ;;   (let ((line-text (delete-and-extract-region start end)))
  ;;     (forward-line n)
  ;;     (if (eobp) (newline))
  ;;     (insert line-text)
  ;;     ;; restore point to original column in moved line
  ;;     (forward-line -1)
  ;;     (move-to-column col)))

  ;; (defun move-line-up (n)
  ;;   "Move the current line up by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) -1 (- n))))

  ;; (defun move-line-down (n)
  ;;   "Move the current line down by N lines."
  ;;   (interactive "p")
  ;;   (move-line (if (null n) 1 n)))

  (defun move-line-up ()
    (interactive)
    (let ((col (current-column)))
      (transpose-lines 1)
      (previous-line 2)
      (move-to-column col)))

  (defun move-line-down ()
    (interactive)
    (let ((col (current-column)))
      (next-line 1)
      (transpose-lines 1)
      (previous-line 1)
      (move-to-column col)))

  ;; (define-key my-keys-map (kbd "M-<up>") 'move-line-up)
  ;; (define-key my-keys-map (kbd "M-<down>") 'move-line-down)

#+end_src
** vims w
#+begin_src emacs-lisp :tangle yes
  (defun char-is (classs dir)
    "t if current char is in any character class in the list classs.
  If dir < 0, do the same check on previous character instead"
    (let ((found nil))
      (dolist (cla classs)
        (setq found (or
                     found
                     (= (char-syntax
                         (if (>= dir 0)
                             (following-char)
                           (preceding-char)))
                        cla))))
      found))

  (defun eriks-next-class (classs dir)
    "Moves point in 'dir' until it encounters something in the character class the list 'classs'"
    (let ((running t)
          (old_onclass (char-is classs dir))
          (onclass nil))
      (while running
        (setq onclass (char-is classs dir))
        (if (and
             (null old_onclass)
             onclass)
            (setq running nil)
          (progn
            (forward-char dir)
            (setq old_onclass onclass))))))

  (defun eriks-next-word (dir)
    "Moves point to the beginning of next word
  or end of previous word if dir < 0"
    (interactive "p")
    (dotimes (i (abs dir))
      (eriks-next-class '(?w) (sign dir))))

  (defun eriks-next-symbol (dir)
    "Moves point to the beginning of next symbol
  or end of previous symbol if dir < 0"
    (interactive "p")
    (dotimes (i (abs dir))
      (eriks-next-class '(?_ ?w) (sign dir))))
#+end_src
* packages
** yasnippet
#+begin_src emacs-lisp :tangle yes
  ;;(require 'yasnippet)
  (yas-global-mode 1)
  ;;(require 'dropdown-list)
  ;;(setq yas-prompt-functions
  ;;      '(yas-dropdown-prompt
  ;;        yas-ido-prompt
  ;;        yas-x-prompt
  ;;        yas-completing-prompt
  ;;        yas-no-prompt))

  ;;removes expanding with tab. Uses 'Auto-complete' instead
  (define-key yas-minor-mode-map (kbd "<tab>") nil)
  (define-key yas-minor-mode-map (kbd "TAB") nil)

#+end_src
** Auto-complete
All default keybindings have been commented out in the source file 'auto-complete.el'

#+begin_src emacs-lisp :tangle yes
  (global-auto-complete-mode 1)
  (ac-config-default)

  (setq ac-dwim nil)

  (add-hook 'auto-complete-mode-hook
            (lambda ()
              ;;(define-key ac-completing-map (kbd "up") nil)
              ;;(define-key ac-completing-map (kbd "down") nil)
              ;;(define-key ac-completing-map (kbd "TAB") 'ac-next)
              (define-key ac-completing-map (kbd "<tab>") 'ac-expand)
              (define-key ac-completing-map (kbd "<backtab>") 'ac-expand-previous)
              (define-key ac-completing-map (kbd "C-o") 'ac-complete)
              ;;(define-key ac-menu-map (kbd "C-o") 'ac-complete)
              (define-key ac-completing-map (kbd "RET") 'ac-stop)
              (define-key ac-completing-map (kbd "C-n") 'ac-next)
              (define-key ac-completing-map (kbd "C-p") 'ac-previous)
              ))

  ;;adds yasnippet snippets to menu
  ;; (eval-after-load "auto-complete"
  ;;   '(add 'ac-sources 'ac-source-yasnippet))
  (eval-after-load "auto-complete"
    (lambda ()
      (add-to-list 'ac-sources 'ac-source-yasnippet)))

  ;;makes a key bring up the popup menu again if auto-complete is enabled
  ;;otherwise, try to expand with yas
  ;;(define-key ac-mode-map)
  (define-key my-keys-map (kbd "S-SPC")
        (lambda ()
          (interactive)
          (if (bound-and-true-p auto-complete-mode)
              (progn
                (ac-trigger-key-command 1)
                (message "auto-complete"))
            (progn
              (yas-expand)
              (message "yasnippet")))))


#+end_src
** undo-tree
#+begin_src emacs-lisp :tangle yes
  (global-undo-tree-mode 1)
  (global-set-key (kbd "C-z") 'undo)
  ;;(define-key my-keys-map (kbd "C-z") 'undo)
  (global-set-key (kbd "C-S-z") 'undo-tree-redo)
  ;;(define-key my-keys-map (kbd "C-S-z") 'undo-tree-redo)
  (define-key eriks-map (kbd "u") 'undo-tree-visualize)
#+end_src
** ivy and avy
#+begin_src emacs-lisp :tangle yes
  ;;ivy
  (ivy-mode 1)
  (global-set-key (kbd "C-s") 'swiper)
  (global-set-key (kbd "M-x") 'counsel-M-x)
  ;;(global-set-key (kbd "C-x C-f") 'counsel-find-file)
  (define-key my-keys-map [remap find-file] 'counsel-find-file)
  ;;(define-key ivy-minibuffer-map (kbd "<tab>") 'ivy-partial)

  ;;avy
  ;;(define-prefix-command 'eriks-avy-map)
  ;;(define-key my-keys-map (kbd "M-s") 'eriks-avy-map)
  ;;(global-set-key (kbd "M-s") 'avy-goto-char)
  (define-key eriks-map (kbd "SPC") 'avy-goto-char)
  (define-key eriks-map (kbd "C-SPC") 'avy-goto-char-2)

  ;;dired
  ;;(add-hook 'dired-mode-hook
  ;;          (lambda ()
  ;;            (define-key dired-mode-map (kbd "M-s s") 'avy-goto-char)))
  (setq ivy-use-selectable-prompt t)
#+end_src
** golden ratio scroll
#+begin_src emacs-lisp :tangle yes
  (global-set-key [remap scroll-down-command] 'golden-ratio-scroll-screen-down)
  (global-set-key [remap scroll-up-command] 'golden-ratio-scroll-screen-up)
#+end_src
** projectile
#+begin_src emacs-lisp :tangle yes
  (projectile-global-mode t)
  (counsel-projectile-on)
#+end_src
** dumb jump
#+begin_src emacs-lisp :tangle yes
  ;;(dumb-jump-mode)

  ;;(fset 'eriks-dumb-jump-keymap (make-sparse-keymap))
  (define-prefix-command 'eriks-dumb-jump-keymap)
  (define-key eriks-map (kbd "j") 'eriks-dumb-jump-keymap)

  (define-key 'eriks-dumb-jump-keymap (kbd "j") 'dumb-jump-go)
  (define-key 'eriks-dumb-jump-keymap (kbd "b") 'dumb-jump-back)

  (setq dumb-jump-selector 'ivy)

#+end_src
** neotree
#+begin_src emacs-lisp :tangle yes
  ;;When running ‘projectile-switch-project’ (C-c p p), ‘neotree’ will change root automatically.
  ;;(setq projectile-switch-project-action 'neotree-projectile-action)

  ;;Every time when the neotree window is opened, let it find current file and jump to node.
  ;;(setq neo-smart-open t)

  ;;Similar to find-file-in-project, NeoTree can be opened (toggled) at projectile project root as follows:
  (defun neotree-project-dir ()
    "Open NeoTree using the git root."
    (interactive)
    (let ((project-dir (projectile-project-root))
          (file-name (buffer-file-name)))
      (neotree-toggle)
      (if project-dir
          (if (neo-global--window-exists-p)
              (progn
                (neotree-dir project-dir)
                (neotree-find file-name)))
        (message "Could not find git project root."))))

  ;; (global-set-key [f8] 'neotree-toggle)
  ;; (global-set-key (kbd "S-<f8>") 'neotree-find)
  ;; (global-set-key [f9] 'neotree-project-dir)

  (defhydra hydra-neotree (:color blue)
    "neotree"
    ("<f8>" neotree-toggle "toggle")
    ("f" neotree-find "file dir")
    ("p" neotree-project-dir "project dir"))
  (define-key my-keys-map (kbd "<f8>") 'hydra-neotree/body)
#+end_src
** multiple cursors
#+begin_src emacs-lisp :tangle yes
  ;; (define-key 'eriks-map (kbd "m l") 'mc/edit-lines)
  ;; (define-key 'eriks-map (kbd "m m") 'mc/mark-next-like-this)
  ;; (define-key 'eriks-map (kbd "m n") 'mc/mark-previous-like-this)
  ;; (define-key 'eriks-map (kbd "m b") 'mc/mark-all-like-this)
#+end_src
** smartparens
*** standard config
#+begin_src emacs-lisp :tangle yes
  (require 'smartparens-config)

  (add-hook 'smartparens-strict-mode-hook (lambda ()
                                            (define-key smartparens-strict-mode-map [remap modalka-kill] 'modalka-sp-kill)
                                            (define-key smartparens-strict-mode-map [remap modalka-delete] 'modalka-sp-delete)))

  (defun start-smartparens ()
    (smartparens-mode t)

    (define-key smartparens-mode-map (kbd "C-M-SPC") 'sp-mark-sexp)

    (define-key smartparens-mode-map (kbd "C-M-n") 'sp-next-sexp)
    (define-key smartparens-mode-map (kbd "C-M-p") 'sp-previous-sexp)

    (define-key smartparens-mode-map (kbd "C-M-u") 'sp-backward-up-sexp)
    (define-key smartparens-mode-map (kbd "C-M-d") 'sp-down-sexp)

    (define-key smartparens-mode-map (kbd "C-M-f") 'sp-forward-sexp)
    (define-key smartparens-mode-map (kbd "C-M-b") 'sp-backward-sexp)

    (define-key smartparens-mode-map (kbd "C-M-k") 'sp-kill-sexp)

    ;;(define-key smartparens-mode-map (kbd "M-f") 'sp-forward-symbol)
    ;;(define-key smartparens-mode-map (kbd "M-b") 'sp-backward-symbol)

    )

  (defun start-hydra-smartparens-if-activated ()
    (interactive)
    (if (bound-and-true-p smartparens-mode)
        (hydra-smartparens/body)
      (message "smartparens not activated!")))

  (define-key eriks-map (kbd "p") 'hydra-smartparens/body) ;;'start-hydra-smartparens-if-activated

  (defhydra hydra-smartparens (:color blue)
    "
   ^forward^      ^backward^     ^Sexp^          ^Hybrid^
  ^^^^^^^^-----------------------------------------------------
   [_m_] : barf   [_i_] : slurp  [_K_] : kill    [_k_] : kill
   [_n_] : slurp  [_o_] : barf   [_s_] : splice  [_w_] : slurp
    ^ ^            ^ ^           [_S_] : split   [_e_] : barf
    ^ ^            ^ ^           [_J_] : join     ^ ^
  "
    ("K" sp-kill-sexp nil)
    ("s" sp-splice-sexp nil)
    ("S" sp-split-sexp nil)
    ("J" sp-join-sexp nil)
    ("m" sp-forward-barf-sexp nil)
    ("n" sp-forward-slurp-sexp nil)
    ("i" sp-backward-slurp-sexp nil)
    ("o" sp-backward-barf-sexp nil)
    ("k" sp-kill-hybrid-sexp nil)
    ("w" sp-slurp-hybrid-sexp nil)
    ("e" sp-dedent-adjust-sexp nil)
    )
  ;;("q" nil "Quit" :color blue)

#+end_src
*** parenthesis
#+begin_src emacs-lisp :tangle yes
  (defun my-create-newline-and-enter-sexp (&rest _ignored)
    "Open a new brace or bracket expression, with relevant newlines and indent. "
    (newline)
    (indent-according-to-mode)
    (forward-line -1)
    (indent-according-to-mode))


  (sp-local-pair '(c-mode java-mode) "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))
  ;;(sp-local-pair 'java-mode "{" nil :post-handlers '((my-create-newline-and-enter-sexp "RET")))

#+end_src
** dashboard
#+begin_src emacs-lisp :tangle yes
  (require 'dashboard)
  (dashboard-setup-startup-hook)

  (setq dashboard-items '((recents  . 5)
                          (bookmarks . 5)
                          (projects . 5)))
#+end_src
** outshine
#+begin_src emacs-lisp :tangle yes
  (require 'outshine)
  ;; (add-hook 'outline-minor-mode-hook 'outshine-hook-function)
  ;; (defvar outline-minor-mode-prefix "\M-#")

#+end_src
** ibuffer
#+begin_src emacs-lisp :tangle yes
  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("dired" (mode . dired-mode))
                 ;;("perl" (mode . cperl-mode))
                 ;;("erc" (mode . erc-mode))
                 ;; ("planner" (or
                 ;;             (name . "^\\*Calendar\\*$")
                 ;;             (name . "^diary$")
                 ;;             (mode . muse-mode)))
                 ("emacs" (or
                           (name . "^\\*scratch\\*$")
                           (name . "^\\*Messages\\*$")
                           (name . "^\\*dashboard\\*$")
                           (mode . help-mode)
                           (name . "^\\*Customize.*")))
                 ("magit" (name . "^\\*magit:.*"))
                 ;; ("gnus" (or
                 ;;          (mode . message-mode)
                 ;;          (mode . bbdb-mode)
                 ;;          (mode . mail-mode)
                 ;;          (mode . gnus-group-mode)
                 ;;          (mode . gnus-summary-mode)
                 ;;          (mode . gnus-article-mode)
                 ;;          (name . "^\\.bbdb$")
                 ;;          (name . "^\\.newsrc-dribble")))
                 ))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))

  (define-key my-keys-map (kbd "C-x C-b") 'ibuffer)
#+end_src
* prog-mode-hook
** prog-mode
#+begin_src emacs-lisp :tangle yes
  (add-hook 'prog-mode-hook
            (lambda ()
              (make-local-variable 'newline-without-break-tab)
              (setq newline-without-break-tab t)
              ;;(autopair-mode 1)
              ;;(paredit-mode t)
              (start-smartparens)
              (setq show-trailing-whitespace t)
              (rainbow-delimiters-mode t)
              (modalka-mode 1)))
#+end_src
** C-like modes
*** common
#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-common-hook
              (lambda ()
                (run-hooks 'abbrev-mode-hook) ;;för att den inte verkar göra det själv
                (setq-local comment-start "//")
                (setq-local comment-end "")

                ;;hs-minor-mode (hideShow)

                ;;(add-to-list 'ac-sources 'ac-source-c-headers)
                ;;(add-to-list 'ac-sources 'ac-source-c-header-symbols t)
                ;; (define-key c-mode-base-map (kbd "<C-S-return>")
                ;;   (lambda ()
                ;;     (interactive)
                ;;     (newline-without-break-up t)))

                ;; (define-key c-mode-base-map (kbd "<C-return>")
                ;;   (lambda ()
                ;;     (interactive)
                ;;     (newline-without-break-down t)))

                ;;(electric-pair-mode 1)
                ;;(make-local-variable 'newline-without-break-tab)
                ;;(setq newline-without-break-tab t)
                ;;(autopair-mode)
                ;;(setq show-trailing-whitespace t)
                ))

#+end_src
*** c
#+begin_src emacs-lisp :tangle yes
  (add-hook 'c-mode-hook
            (lambda ()
              (flycheck-mode 1)
              ))
#+end_src
*** java
#+begin_src emacs-lisp :tangle yes
  (require 'eclim)
  (setq eclimd-autostart nil)

  (custom-set-variables
   '(eclim-eclipse-dirs '("~/bin/eclipse-neon"))
   '(eclim-executable "~/bin/eclipse-neon/eclim"))

  ;;(setq help-at-pt-display-when-idle t)
  ;;(setq help-at-pt-timer-delay 0.1)
  ;;(help-at-pt-set-timer)

  (add-hook 'eclim-mode-hook
            (lambda ()
              (define-key eclim-mode-map (kbd "C-c C-e C-b") 'eclim-project-build)
              (define-key eclim-mode-map (kbd "C-c C-e d") nil)
              (define-key eclim-mode-map (kbd "C-c C-e d d") 'eclim-java-show-documentation-for-current-element)
              (define-key eclim-mode-map (kbd "C-c C-e d f") 'eclim-java-browse-documentation-at-point)
              (define-key eclim-mode-map (kbd "C-c C-e d s") 'eclim-java-doc-comment)
              ))

  (add-hook 'java-mode-hook
            (lambda ()
              (start-eclim-if-inside-eclipse-workspace)))

  (defun eclim-java-start ()
    (interactive)
    (eclim-mode t)
    (require 'ac-emacs-eclim)
    ;;(ac-emacs-eclim-config)
    (ac-emacs-eclim-java-setup)
    )

  (defun start-eclim-if-inside-eclipse-workspace ()
    (if (null (search "workspace" (buffer-file-name)))
        ()
      (eclim-java-start)))


#+end_src
** lisp hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (smartparens-strict-mode t)
              ;;(make-local-variable 'newline-without-break-tab)
              ;;(setq newline-without-break-tab t)
              ;;(autopair-mode)
              ;;(setq show-trailing-whitespace t)
              ))

#+end_src
** perl hook
#+begin_src emacs-lisp :tangle yes
  (add-hook 'perl-mode-hook
            (lambda ()
              ;; (define-key perl-mode-map (kbd "<C-S-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-up t)))

              ;; (define-key perl-mode-map (kbd "<C-return>")
              ;;   (lambda ()
              ;;     (interactive)
              ;;     (newline-without-break-down t)))

              ;; (electric-pair-mode 1)
              ))
#+end_src
* Hydra
** various hydras
#+begin_src emacs-lisp :tangle yes
  ;; font zoom
  (defhydra hydra-zoom ()
    "zoom"
    ("g" text-scale-increase "in")
    ("l" text-scale-decrease "out")
    ("q" nil "quit" :color blue))
  (define-key eriks-map (kbd "z") 'hydra-zoom/body)

  (defhydra hydra-windows (:hint nil)
    "
   ^Resize^         ^Transpose^    ^Buffer/tabbar^       ^^^^   ^Split^
  -----------------------------------------------------------------------------------
    ^Horizontal^        ^_W_^           ^_w_^                   [_3_] : horizontal
   [_o_] : shrink     _A_   _D_       _a_   _d_                 [_2_] : vertical
   [_p_] : enlarge      ^_S_^           ^_s_^                   [_0_] : close
    ^ ^                                               ^^^^^^^^  [_1_] : close other
    ^Vertical^         ^^          [_b_] : switch buffer  ^^^^  [_+_] : balance
   [_u_] : shrink      ^^          [_K_] : kill           ^^^^  [_4_] : kill and close
   [_i_] : enlarge     ^^          [_f_] : find file        ^ ^
   ^ ^                 ^^          [_x_] : run command
   [vim keys] : switch window   Winner :: [_z_], [_Z_]
   _q_uit
  "
    ;; _q_uit
    ("h" windmove-left nil)
    ("l" windmove-right nil)
    ("k" windmove-up nil)
    ("j" windmove-down nil)
    ("o" shrink-window-horizontally nil)
    ("p" enlarge-window-horizontally nil)
    ("u" shrink-window nil)
    ("i" enlarge-window nil)
    ("W" buf-move-up nil)
    ("S" buf-move-down nil)
    ("A" buf-move-left nil)
    ("D" buf-move-right nil)
    ("d" tabbar-forward-tab nil)
    ("a" tabbar-backward-tab nil)
    ("w" tabbar-forward-group nil)
    ("s" tabbar-backward-group nil)
    ("b" ivy-switch-buffer nil)
    ("K" kill-this-buffer nil)
    ("3" split-window-horizontally nil)
    ("2" split-window-vertically nil)
    ("0" delete-window nil)
    ("1" delete-other-windows nil)
    ("+" balance-windows nil)
    ("4" kill-buffer-and-window nil)
    ("x" execute-extended-command nil)
    ("f" find-file nil)
    ("z" winner-undo nil)
    ("Z" winner-redo nil)
    ("q" nil nil :color blue))
  (define-key 'eriks-map (kbd "w") 'hydra-windows/body)

  (defhydra hydra-multiple-cursors ()
    "
       ^Up^            ^Down^        ^Other^
  ----------------------------------------------
  [_p_]   Next    [_n_]   Next    [_l_] Edit lines
  [_P_]   Skip    [_N_]   Skip    [_a_] Mark all
  [_M-p_] Unmark  [_M-n_] Unmark  [_r_] Mark by regexp
  ^ ^             ^ ^             [_q_] Quit
  "
    ("l" mc/edit-lines nil :exit t)
    ("a" mc/mark-all-like-this nil :exit t)
    ("n" mc/mark-next-like-this nil)
    ("N" mc/skip-to-next-like-this nil)
    ("M-n" mc/unmark-next-like-this nil)
    ("p" mc/mark-previous-like-this nil)
    ("P" mc/skip-to-previous-like-this nil)
    ("M-p" mc/unmark-previous-like-this nil)
    ("r" mc/mark-all-in-region-regexp nil :exit t)
    ("q" nil nil))
  (define-key 'eriks-map (kbd "m") 'hydra-multiple-cursors/body)


#+end_src
** transpose
#+begin_src emacs-lisp :tangle yes
  (defun eriks-transpose-char-forward ()
    (interactive)
    (forward-char)
    (transpose-chars 1)
    (forward-char -1))

  (defun eriks-transpose-char-backward ()
    (interactive)
    (transpose-chars 1)
    (forward-char -2))

  (defun eriks-transpose-word-forward ()
    (interactive)
    (transpose-words 1))

  (defun eriks-transpose-word-backward ()
    (interactive)
    (transpose-words -1)
    (backward-word))

  (defun eriks-transpose-paragraph-forward ()
    (interactive)
    (transpose-paragraphs 1))

  (defun eriks-transpose-paragraph-backward ()
    (interactive)
    (transpose-paragraphs -1)
    (backward-paragraph))

  (defun eriks-exchange-paragraphs ()
    (interactive)
    (transpose-paragraphs 0))

  (defhydra hydra-transpose ()
    "Transpose: "
    ("k" move-line-up "line up")
    ("j" move-line-down "line down")
    ("h" eriks-transpose-char-backward "char backward")
    ("l" eriks-transpose-char-forward "char forward")
    ("f" eriks-transpose-word-forward "word forward")
    ("b" eriks-transpose-word-backward "word backward")
    ("n" eriks-transpose-paragraph-forward "paragraph forward")
    ("p" eriks-transpose-paragraph-backward "paragraph backward")
    ("e" eriks-exchange-paragraphs "paragraph exhange")
    ("q" nil "quit"))


#+end_src
** org-table to hydra
*** macro definition
#+begin_src emacs-lisp :tangle yes
  (fset 'org-table-to-hydra-docstring
     (lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote ([134217788 134217843 115 92 40 32 43 92 41 92 40 46 42 63 92 41 92 40 32 42 124 92 41 13 134217788 67108896 5 134217843 114 92 49 94 92 50 94 92 51 13 33 134217788 134217843 115 124 92 40 32 92 123 50 44 92 125 92 41 13 134217788 134217843 114 124 94 94 92 49 13 33 134217788 134217843 115 92 40 95 46 42 63 95 92 41 13 134217843 114 91 92 49 93 13 33 134217788 3 3 134217843 115 124 13 134217843 114 13 33 134217788 14 deletechar deletechar 94 94 134217843 115 45 92 43 45 13 134217843 114 94 94 13 33 134217788] 0 "%d")) arg)))

#+end_src

*** example
| head1      | head2      | head3            | head4      |
|------------+------------+------------------+------------|
| _h_ : grej | _g_ : sasd | _<right>_ : hej! | _a_ : asd! |
|            |            | _F_       : :)   |            |

==> formated as raw string

 ^head1^       ^head2^       ^head3^             ^head4^
^^-----------^^------------^^------------------^^-------------
 [_h_] : grej  [_g_] : sasd  [_<right>_] : hej!  [_a_] : asd!
 ^^            ^^            [_F_]       : :)    ^^

==> end result in hydra

 head1       head2       head3             head4
------------------------------------------------------
 [h] : grej  [g] : sasd  [<right>] : hej!  [a] : asd!
                         [F]       : :)
** rectangles
#+begin_src emacs-lisp :tangle yes
  (require 'picture)

  (defun pic-move (x y)
    "Uses picture-mode movement commands"
    ;;(interactive "P\nP")
    (cond
     ((> x 0) (picture-forward-column x))
     ((< x 0) (picture-backward-column (- x))))
    (cond
     ((> y 0) (picture-move-down y))
     ((< y 0) (picture-move-up (- y)))))

  ;; (defun mark-column ()
  ;;   (exchange-point-and-mark)
  ;;   (let ((col (current-column)))
  ;;     (exchange-point-and-mark)
  ;;     col))

  ;; (defun put-point-top-left-corner ()
  ;;   (line-number-at-pos (point))
  ;;   (let )
  ;;   (if (> (point) (mark))
  ;;       (exchange-point-and-mark)))

  ;; (defun move-rect (x y)
  ;;   (interactive "P\nP")
  ;;   (put-point-top-left-corner)
  ;;   (kill-rectangle)
  ;;   (pic-move x y)
  ;;   (let ((oldp (point)))
  ;;     )


  ;;   )

  ;; (move-rect 0 -1)


  (defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                       :color pink
                                       :hint nil
                                       :post (progn (deactivate-mark) (whitespace-cleanup)))
    "
    ^_k_^       _w_ copy      _o_pen       _N_umber-lines            |\\     -,,,--,,_
  _h_   _l_     _y_ank        _t_ype       _e_xchange-point          /,`.-'`'   ..  \-;;,_
    ^_j_^       _d_ kill      _c_lear      _r_eset-region-mark      |,4-  ) )_   .;.(  `'-'
  ^^^^          _u_ndo        _q_ quit     ^ ^                     '---''(./..)-'(_\_)
  "
    ("k" (pic-move 0 -1))
    ("j" (pic-move 0 1))
    ("h" (pic-move -1 0))
    ("l" (pic-move 1 0))
    ("d" kill-rectangle)                    ;; C-x r k
    ("y" yank-rectangle)                    ;; C-x r y
    ("w" copy-rectangle-as-kill)            ;; C-x r M-w
    ("o" open-rectangle)                    ;; C-x r o
    ("t" string-rectangle)                  ;; C-x r t
    ("c" clear-rectangle)                   ;; C-x r c
    ("e" exchange-point-and-mark)           ;; C-x C-x
    ("N" rectangle-number-lines)            ;; C-x r N
    ("r" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)))
    ("u" undo nil)
    ("q" nil nil))
  (define-key my-keys-map (kbd "C-x SPC") 'hydra-rectangle/body)
#+end_src
** tags
#+begin_src emacs-lisp :tangle yes
  (setq path-to-ctags "/usr/bin/ctags")

  (defun create-tags (dir-name)
    "Create tags file."
    (interactive "DDirectory: ")
    (shell-command (format "%s -f TAGS -e -R \"%s\"" path-to-ctags (directory-file-name dir-name))))

  (defhydra hydra-tags (:color blue :hint nil)
    "
   ^Setup^                    ^Find^
  ^^^^----------------------------------------------------
   _c_reate                   _f_ind (-=back, u=continue)
   _v_isit-tags-table         _s_earch
   _r_egenerate (projectile)  _p_op
        ^^                    _l_oop-continue
   _q_uit                     _P_rojectile find
  "
    ("c" create-tags nil :color red)
    ("v" visit-tags-table nil :color red)
    ("r" projectile-regenerate-tags nil :color red)
    ("f" find-tag nil)
    ("s" tags-search nil)
    ("p" pop-tag-mark nil)
    ("l" tags-loop-continue nil)
    ("P" projectile-find-tag nil)
    ("q" nil nil :color blue))

  (defhydra hydra-gtags (:color blue :hint nil)
    "
  ^Counsel^
  ------------------------------------------
  _d_ find definition    _n_ go forward   
  _r_ find reference     _f_ find dwim
  _s_ find symbol        _u_ update gtags
  _F_ find file          _c_ create gtags
  _b_ go back
  "
    ("d" counsel-gtags-find-definition nil)
    ("r" counsel-gtags-find-reference nil)
    ("s" counsel-gtags-find-reference nil)
    ("F" counsel-gtags-find-file nil)
    ("b" counsel-gtags-go-backward nil)
    ("n" counsel-gtags-go-forward nil)
    ("f" counsel-gtags-dwim)
    ("c" counsel-gtags-create-tags nil)
    ("u" counsel-gtags-update-tags)
    ("q" nil nil :color blue))

  (define-key eriks-map (kbd "t") 'hydra-gtags/body)
#+end_src
* modalka
** general
#+begin_src emacs-lisp :tangle yes
  (require 'modalka)

  (defun toggle-modalka ()
    (interactive)
    (modalka-mode 'toggle)
    (if (bound-and-true-p modalka-mode)
        (setq modalka-insert-text nil)))

  (define-key my-keys-map (kbd "§") 'toggle-modalka)

  (define-key modalka-mode-map (kbd "t") 'hydra-transpose/body)

  (modalka-define-kbd "W" "M-w")
  (modalka-define-kbd "a" "C-a")
  (modalka-define-kbd "e" "C-e")
  (modalka-define-kbd "y" "C-y")
  (modalka-define-kbd "Y" "M-y")

  (define-key modalka-mode-map (kbd "m") 'set-mark-command)

  (modalka-define-kbd "u" "C-u")

  (modalka-define-kbd ";" "M-;")

  (define-key modalka-mode-map (kbd "c") 'eriks-duplicate-line)

  ;;vim
  (modalka-define-kbd "h" "C-b")
  (define-key modalka-mode-map (kbd "j") 'next-line)
  (define-key modalka-mode-map (kbd "k") 'previous-line)
  (modalka-define-kbd "l" "C-f")

  (modalka-define-kbd "H" "C-M-b")
  (modalka-define-kbd "K" "C-M-u")
  (modalka-define-kbd "J" "C-M-d")
  (modalka-define-kbd "L" "C-M-f")

  (define-key modalka-mode-map (kbd "C-k") 'backward-paragraph)
  (define-key modalka-mode-map (kbd "C-j") 'forward-paragraph)

  (modalka-define-kbd "f" "M-f")
  (modalka-define-kbd "b" "M-b")
  (define-key modalka-mode-map "F" 'forward-symbol)
  (define-key modalka-mode-map "B" 'backward-symbol)

  (define-key modalka-mode-map (kbd "q") 'eriks-next-word)
  (define-key modalka-mode-map (kbd "Q") 'eriks-next-symbol)

  (define-key modalka-mode-map (kbd "D") 'modalka-kill)
  (define-key modalka-mode-map (kbd "d") 'modalka-delete)
  (define-key modalka-mode-map (kbd "M") 'modalka-select)
  (define-key modalka-mode-map (kbd "S") 'modalka-swiper)

  (define-key modalka-mode-map (kbd ".") 'modalka-repeat)
  (define-key modalka-mode-map (kbd ",") 'repeat)
  (define-key modalka-mode-map (kbd ":") 'modalka-repeat-lock)
  ;;(define-key modalka-mode-map (kbd "SPC") 'eriks-map)
  (define-key modalka-mode-map (kbd "SPC") 'self-insert-command)
  (define-key modalka-mode-map (kbd "i") 'toggle-modalka)

  (define-key modalka-mode-map (kbd "å") 'eriks-insert-char)
  (define-key modalka-mode-map (kbd "I") 'modalka-insert-text)

  (modalka-define-kbd "o" "C-<return>")
  (modalka-define-kbd "O" "C-S-<return>")
  (modalka-define-kbd "+" "C-+")
  (define-key modalka-mode-map (kbd "p") 'hydra-smartparens/body)

  (modalka-define-kbd "s" "C-s")

  (modalka-define-kbd "v" "C-v")
  (modalka-define-kbd "V" "M-v")

  (modalka-define-kbd "r" "C-r")
  (modalka-define-kbd "x" "<deletechar>")
  (modalka-define-kbd "X" "DEL")

  ;;avy
  (define-key modalka-mode-map (kbd "g") 'avy-goto-char)
  (define-key modalka-mode-map (kbd "G l") 'avy-goto-line)
  (define-key modalka-mode-map (kbd "G w") 'avy-goto-word-0)
  (define-key modalka-mode-map (kbd "G n") 'goto-line)
  (define-key modalka-mode-map (kbd "G a") 'beginning-of-buffer)
  (define-key modalka-mode-map (kbd "G e") 'end-of-buffer)

  (define-key modalka-mode-map (kbd "w f") 'eriks-skip-space)
  (define-key modalka-mode-map (kbd "w b") 'eriks-skip-space-backwards)

  (modalka-define-kbd "<left>" "")
  (modalka-define-kbd "<right>" "")
  (modalka-define-kbd "<down>" "")
  (modalka-define-kbd "<up>" "")

  (dotimes (i 10)
    (modalka-define-kbd (format "%d" i) (format "M-%d" i)))

  (modalka-define-kbd "-" "M--")

  (define-key modalka-mode-map (kbd "n") 'eriks-find-char)
  (define-key modalka-mode-map (kbd "N") 'eriks-find-char-backward)

#+end_src
** action region
#+begin_src emacs-lisp :tangle yes
  (setq modalka-action-region-special-map (make-sparse-keymap))

  (defun eriks-bind-bounds-thing (keys thing)
    (define-key modalka-action-region-special-map (kbd keys)
       `(lambda ()
         (interactive)
         (bounds-of-thing-at-point ',thing))))

  (eriks-bind-bounds-thing "i w" 'word)
  (eriks-bind-bounds-thing "i W" 'symbol)
  (eriks-bind-bounds-thing "i l" 'line)
  (eriks-bind-bounds-thing "i p" 'paragraph)
  (eriks-bind-bounds-thing "i d" 'defun)
  (eriks-bind-bounds-thing "i s" 'whitespace)

  (defun eriks-buffer-bounds ()
    (interactive)
    (end-of-buffer)
    (cons 1 (point)))

  (define-key modalka-action-region-special-map (kbd "i b") 'eriks-buffer-bounds)
  (define-key modalka-action-region-special-map (kbd "n") 'eriks-find-char-alt)
  (define-key modalka-action-region-special-map (kbd "u") 'eriks-find-char)
  (define-key modalka-action-region-special-map (kbd "N") 'eriks-find-char-backward)
  (define-key modalka-action-region-special-map (kbd "U") 'eriks-find-char-alt-backward)

  (defun is-bounds (b)
    "True if b is of the form (a . b) where a and b are integers"
    (and
     (consp b)
     (integerp (car b))
     (integerp (cdr b))))

  (defun read-keys-with-prefix (prefix prompt)
    (let ((keys (read-key-sequence-vector prompt)))
      (if (seq-contains modalka-repeat-prefix-keys (car (listify-key-sequence keys)))
          (read-keys-with-prefix (cons (aref keys 0) prefix) (format "%s -%s" prompt (key-description keys)))
        (cons (reverse-list prefix) keys))))

  (defun reverse-list (l &optional temp)
    (if (null l)
        temp
      (reverse-list (cdr l) (cons (car l) temp))))

  ;;(parse-prefix (car (read-keys-with-prefix nil "hej:")))
  (defun parse-prefix (prefix)
    (if (null prefix)
        nil
      (let ((uni 0)
            (neg nil)
            (num 0)
            (pre prefix)
            (cur nil))
        (while (not (null pre))
          (setq cur (car pre))
          (setq pre (cdr pre))
          (cond
           ((= cur 117)
            (setq uni (+ uni 1)))
           ((= cur 45)
            (setq neg t))
           (t
            (setq num (+ (* 10 num) (- cur 48))))))
        (cond
         ((> uni 0)
          (list (expt 4 uni)))
         ((and neg (= num 0))
          '-)
         (neg
          (- 0 num))
         (t
          num)))))

  (defun modalka-action-region (prompt &optional ignore-active-region)
    (if (and
         (region-active-p)
         (not ignore-active-region))
        (cons (region-beginning) (region-end))
      (let ((old-prefix current-prefix-arg))
        (unwind-protect
            (let ((keys nil)
                  (return nil)
                  (start (point))
                  (end nil))
              (setq current-prefix-arg nil)
              (setq overriding-terminal-local-map modalka-action-region-special-map)
              (setq prev-command-keys (this-command-keys-vector))
              (setq keys (read-keys-with-prefix nil prompt))
              (setq prev-command-keys (vconcat prev-command-keys (car keys)))
              (setq current-prefix-arg (parse-prefix (car keys)))
              (setq return (call-interactively (key-binding (cdr keys))))
              ;;(message "")
              (if (is-bounds return)
                  return
                (progn
                  (setq end (point))
                  (if (= start end)
                      nil
                    (cons start end)))))
          (progn
            (setq overriding-terminal-local-map nil)
            (setq current-prefix-arg old-prefix))))))

  (defun modalka-kill-delete-region (name func)
    (let ((region (modalka-action-region name)))
      (if region
          (funcall func (car region) (cdr region))
        (message "no region"))))

  (defun modalka-kill ()
    (interactive)
    (modalka-kill-delete-region "Kill: " 'kill-region))

  (defun modalka-delete ()
    (interactive)
    (modalka-kill-delete-region "Delete: " 'delete-region))

  (defun modalka-sp-delete ()
    (interactive)
    (modalka-kill-delete-region "sp-delete: " 'sp-delete-region))

  (defun modalka-sp-kill ()
    (interactive)
    (modalka-kill-delete-region "sp-kill: " 'sp-kill-region))

  (defun modalka-select ()
    (interactive)
    (let* ((ra (region-active-p))
          (region (modalka-action-region "Select: " ra)))
      (if (and (not ra) region)
          (progn
            (goto-char (car region))
            (set-mark-command nil)
            (goto-char (cdr region))
            ;; (setq real-this-command (key-binding modalka-action-region-last-keys))
            )
        (message "no region"))))

  (defun modalka-swiper ()
    (interactive)
    (let ((region (modalka-action-region "Swiper: ")))
      (if region
          (swiper (buffer-substring (car region) (cdr region)))
        (message "no region"))))
#+end_src
** repeat o lighter
#+begin_src emacs-lisp :tangle yes
  (setq modalka-repeat-lock nil)
  (setq modalka-insert-text nil)
  (setq modalka-insert-text-first nil)

  ;;keys som det senaste kommandot hade
  (setq modalka-repeat-cur-macro nil)

  ;;om man kör `read-key-sequence' eller liknande i sin funktion kommer
  ;;den att skriva över `this-command-keys'. Så för att bevara sin
  ;;key-sequence för att kunna repetera sätter man denna variabel
  (setq prev-command-keys nil)

  ;; saker i modalka som inte ska repeatas
  (setq modalka-repeat-whitelist
        (mapcar
         (lambda (a)
           (listify-key-sequence (kbd a)))
         '("M" "D" "d" "n" "N" "I" "r" "x" "X" "c" "å")))

  ;; funktioner som inte ska repeatas
  (setq modalka-repeat-blacklist-function '(modalka-repeat undo-tree-undo modalka-mode toggle-modalka))

  ;; vilka knappar som är för prefix-argument
  (setq modalka-repeat-prefix-keys (listify-key-sequence (kbd "0 1 2 3 4 5 6 7 8 9 u -")))

  ;;keys listified
  (defun modalka-repeat-remove-prefix (keys)
    (if (seq-contains modalka-repeat-prefix-keys (car keys))
        (modalka-repeat-remove-prefix (cdr keys))
      keys))

  ;;removes common prefix from a and b
  (defun list-prefix (a b)
    (if (and
         (equal (car a) (car b))
         (not (null a))
         (not (null b)))
        (list-prefix (cdr a) (cdr b))
      (cons a b)))

  ;;checks whether a is a prefix of b
  ;;(is-prefix-of '(1 2 3) '(1 2 3 4 5)) == t
  (defun is-prefix-of (a b)
    (null (car (list-prefix a b))))

  ;; assumes `modalka-repeat-cur-macro' ends with § or whatever character toggles modalka
  (defun modalka-insert-text-append (a)
    (setq modalka-repeat-cur-macro (vconcat
                                    (seq-subseq modalka-repeat-cur-macro 0 -1)
                                    a
                                    (listify-key-sequence (kbd "§")))))

  (defun modalka-repeat-post-command ()
    (let* ((keys (vconcat prev-command-keys (this-command-keys-vector)))
           (non-prefix-keys (modalka-repeat-remove-prefix (listify-key-sequence keys))))
      (cond
       ((or
         modalka-repeat-lock
         (seq-contains modalka-repeat-blacklist-function real-this-command 'eq)) nil)
       (modalka-insert-text
        (if modalka-insert-text-first
            (progn
              (setq modalka-insert-text-first nil)
              (setq modalka-repeat-cur-macro (vconcat keys (listify-key-sequence (kbd "§")))))
          (modalka-insert-text-append keys)))
       (t
        (if (and
             (bound-and-true-p modalka-mode)
             (not (null non-prefix-keys))
             (seq-contains
              modalka-repeat-whitelist
              non-prefix-keys
              (lambda (elt e)
                (is-prefix-of e elt))))
            (setq modalka-repeat-cur-macro keys))))
      (setq prev-command-keys nil)
      (modalka-set-lighter)))

  (defun get-color-string (s c)
    (propertize s 'face `(:foreground ,c)))

  (defun modalka-status-color ()
    (cond
     ((and modalka-mode modalka-repeat-lock)
      "red")
     (modalka-mode
      "cyan")
     (modalka-insert-text
      "green")
     (t
      "gray")))

  (defun modalka-set-lighter ()
    (diminish 'modalka-status-mode (format " %s%s%s"
                                           (get-color-string "(" (modalka-status-color))
                                           (concat (seq-remove
                                                    'is-boundary
                                                    (key-description modalka-repeat-cur-macro)))
                                           (get-color-string ")" (modalka-status-color)))))

  (add-hook 'post-command-hook 'modalka-repeat-post-command)

  (defun modalka-repeat-lock ()
    (interactive)
    (setq modalka-repeat-lock (not modalka-repeat-lock)))

  (defun modalka-repeat (ARG)
    (interactive "p")
    ;; (setq this-command last-command) ;;so 'repeat' won't repeat this function and get stuck in an infinite loop
    ;; (setq real-this-command last-repeatable-command)
    (message "repeating %s" (key-description modalka-repeat-cur-macro))
    (execute-kbd-macro modalka-repeat-cur-macro ARG))

  (define-minor-mode modalka-status-mode
    "Displays the next/current command to be repeated by `modalka-repeat' in the modeline"
    :lighter " (nil)"
    :global t
    :init-value t)

  (modalka-status-mode 1)

  (defun modalka-insert-text ()
    (interactive)
    (if modalka-repeat-lock
        (message "Modalka is locked! aborting...")
      (progn
        (setq modalka-insert-text t)
        (setq modalka-insert-text-first t)
        (toggle-modalka))))


#+end_src
* hide minor mode lighters in modeline
#+begin_src emacs-lisp :tangle yes
  ;;shorten minor mode

  (add-hook 'autopair-mode-hook
            (lambda ()
              (diminish 'autopair-mode)))

  ;;(diminish 'counsel-mode)
  (diminish 'which-key-mode)
  (diminish 'ivy-mode)
  (diminish 'undo-tree-mode)
  (diminish 'auto-complete-mode)
  (diminish 'yas-minor-mode)
  (diminish 'global-disable-mouse-mode)
  (diminish 'auto-revert-mode)

  (diminish 'modalka-mode)
  ;;rm-text-properties, ta bort sakerna som smart-mode-line lägger till (face och sml/global(?)).
  ;; (diminish 'modalka-mode (format " %s" (propertize (all-the-icons-fileicon "emacs")
  ;;                                                   'face `(:family ,(all-the-icons-fileicon-family) :height 0.8 :foreground "cyan")
  ;;                                                   'display '(raise -0.1)
  ;;                                                   )))

  (diminish 'my-keys-minor-mode (format " %s" (propertize (all-the-icons-faicon "keyboard-o")
                                                          'face `(:family ,(all-the-icons-faicon-family) :height 0.9)
                                                          'display '(raise 0.0)
                                                          )))

  (diminish 'outline-minor-mode (propertize " O" 'face '(:foreground "green")))

  (diminish 'smartparens-mode)

  (diminish 'projectile-mode)
  (diminish 'all-the-icons-dired-mode)

  ;; (add-hook 'smartparens-mode-hook
  ;;           (lambda ()
  ;;             (diminish 'smartparens-mode)))

  ;;doesnt run :(
  (add-hook 'abbrev-mode-hook
            (lambda ()
              (diminish 'abbrev-mode)))
#+end_src

